# MCP Web Bridge – Deep Research Report (2025-09-07)

## Current State Assessment (Baseline)

**Architecture & Message Schema:** The extension is structured as a Manifest V3 Chrome extension with a **background service worker** for logic and a **content script** for UI. All interactions use a typed message-passing schema (via chrome.runtime.sendMessage), enforcing **Content Script = UI only** and **Background = logic only**[\[1\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L10-L19). The message schema defines distinct kind values for each action, with stable request/response formats including an ok flag and either data or error field[\[2\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L18-L26). Current implemented message kinds cover settings and server management: **GET_SETTINGS**, **SET_SETTINGS**, **LIST_SERVERS**, **TOGGLE_SERVER**, **SET_DEFAULT**[\[3\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/router.js#L6-L13). These are handled in the background router (background/router.js), which loads persistent settings and updates storage as needed[\[4\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/router.js#L16-L24)[\[5\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/router.js#L32-L40). For example, LIST_SERVERS returns the saved server list and default ID[\[6\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/router.js#L28-L35). Planned (but not yet implemented in code) are MCP operation messages like **CONNECT_MCP**, **LIST_MCP_TOOLS**, **CALL_MCP_TOOL**, as well as dev/health messages (PING, LOG, LIST_LOGS, CLEAR_LOGS, etc.) and status updates (SAVE_STATUS, LIST_STATUS)[\[2\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L18-L26). These appear in design/ADR documents and the code schema but have no handler in the current router (unrecognized kinds return an error)[\[7\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/router.js#L46-L50), indicating they are slated for upcoming milestones.

**Storage Model:** The extension uses Chrome Storage with a clear split between **sync** and **local** data[\[8\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L22-L29). **Persistent configuration** (settings) is stored in chrome.storage.sync under a versioned global key (e.g. "mcp.webbridge.global.v1") containing the list of MCP servers, their enabled/default status, and perhaps minor metadata[\[9\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L56-L64)[\[10\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DESIGN.md#L46-L54). On first install, this is initialized with one **seeded server entry** for “Local Echo” (the test MCP server) with enabled: false[\[11\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L34-L42)[\[12\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L86-L89). The background’s ensureSettings() function creates this default config if none exists. **Volatile state** like connection statuses and logs are kept in chrome.storage.local (keys like "mcp.webbridge.status.v1" and "mcp.webbridge.logs.v1")[\[10\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DESIGN.md#L46-L54). The logs are an array of recent events (capped to ~500 entries) for debugging[\[13\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L58-L61), and a timestamp of extension installation is stored (mcp.webbridge.installedAt). The log utility (background/log.js) appends entries with timestamp, level, message, and metadata, and trims the array to the bound size on each write[\[14\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/log.js#L4-L12). This ensures no unbounded growth. The design mandates **no sensitive data in logs** and no telemetry – logs are local and intended for developer inspection[\[15\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L44-L51). In the current implementation (Milestone 1 “core”), **no MCP network connections are made and thus no statuses are yet recorded**[\[16\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L96-L103) beyond toggles and settings changes.

**MCP Connection Logic:** As of the baseline, the extension does **not yet manage external MCP connections** (the README explicitly notes “No MCP network connections” in M1[\[16\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L96-L103)). There is a placeholder for a **MCP Connection Manager** in the architecture design[\[17\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DESIGN.md#L10-L15), intended to handle WebSocket JSON-RPC connections to MCP servers. However, no background/mcpManager.js exists yet and messages like CONNECT_MCP are not handled in the router. This means currently toggling a server or setting it as default does not initiate any network activity – these actions only update the stored settings and log the event[\[18\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/router.js#L34-L42)[\[19\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L50-L58). The “Local Echo” server entry in settings is effectively inert in M1. We anticipate that in Milestone 2 the **connection lifecycle** will be implemented: establishing a WebSocket (likely to ws://127.0.0.1:8788 for Local Echo by default), performing an **initialize** RPC handshake, retrieving available tools, and enabling tool invocations. At present, these steps are manual – for instance, a developer can run the provided scripts/mcp-localdev.js to start a local WebSocket server and then, once the extension supports it, use “Connect” to that server. In M1, the absence of connection logic also means **no error handling or retries** are in place for server connectivity – this is a gap to be filled in the next iteration.

**UI Injection & DOM Strategy:** The content script creates a **Shadow DOM** UI, injecting a sidebar panel and a toggle “chip” into the ChatGPT webpage without interfering with the page’s own DOM styling[\[20\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L30-L38)[\[21\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L34-L42). On page load, content/mount.js runs and appends a &lt;div id="mcp-webbridge-root"&gt; to the page’s document, then attaches an open shadow root to it[\[22\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L40-L48). Inside the shadow root, the extension builds a sidebar (.mcp-sidebar) that slides in/out and a small tab label (the “MCP” chip) that sticks out when collapsed[\[23\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L14-L22)[\[24\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L60-L68). All extension UI elements use classes prefixed with mcp- and are styled within the shadow DOM using injected &lt;style&gt; rules[\[25\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L2-L10)[\[23\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L14-L22), preventing style leakage to or from the host page. The **anchoring strategy** uses a stable selector: the extension attempts to position the MCP chip adjacent to ChatGPT’s composer form (identified by form\[data-type="unified-composer"\])[\[26\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L150-L158)[\[27\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L38-L46). If this element is found, the chip’s position is set just above the composer (with some offset) so it appears near the input box[\[28\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L150-L159). If not found (e.g., due to a page change or a different layout), the code falls back to a default fixed position at bottom-right of the window[\[29\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L164-L172). A **MutationObserver** is attached to the page’s &lt;body&gt; to watch for SPA navigation or DOM changes that might affect the composer; on any change, the extension re-checks the composer’s presence and repositions the chip (or applies the fallback) accordingly[\[30\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L176-L184). A window resize event also triggers repositioning[\[31\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L178-L182). This ensures the MCP UI is persistent and visible even as the user navigates between chats or the page re-renders, fulfilling the requirement that the UI “never disappears” even if the anchor is lost[\[27\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L38-L46). In practice, testing shows that the chip stays anchored on the ChatGPT interface across new chats, history view, and after refresh[\[32\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L64-L73). The sidebar itself is toggled by clicking the chip, using a simple CSS translateX transition to slide in without overlapping ChatGPT’s content[\[23\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L14-L22)[\[24\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L60-L68).

**Current UI & Status Indicators:** The present UI (Milestone 1) includes a **“Servers” tab** in the sidebar (the only tab so far) which lists configured MCP servers[\[33\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L66-L74)[\[34\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L76-L84). Each server entry shows its name, description, an “Enabled” checkbox toggle, and a “Set default” button[\[35\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L94-L103)[\[36\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L118-L126). These controls are wired to send background messages: toggling calls TOGGLE_SERVER and then refreshes the list[\[37\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L110-L118), and setting default calls SET_DEFAULT then refreshes[\[36\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L118-L126). Importantly, in the current version **there are no live status dots or color indicators** next to servers – the UI does not yet reflect whether a server is connected, disconnected, or errored. In fact, enabling/disabling only affects the stored flag. The design documents note that status indicators will be addressed in a later milestone (e.g., showing success/failure status)[\[38\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md#L24-L32), but at baseline these are **not implemented (no green/red dots or similar)**. Likewise, the extension **action icon’s badge** is not used in M1 – no calls to chrome.action.setBadgeText exist yet. All user-facing feedback in M1 is minimal by design: no toasts or error messages are shown for these actions (since they can’t fail meaningfully without networking). Instead, developers are expected to check the background console logs for verification. For example, the quickstart instructs checking the service worker console for log entries when toggling a server, e.g. \[info\] TOGGLE_SERVER { id: "local-echo", enabled: true }[\[19\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L50-L58). This confirms that the background handled the message and updated storage. In summary, the **M1 UI serves as a static shell** to verify that the extension loaded and can store settings, with all dynamic MCP functionality (connecting to servers, listing tools, running tools, error signaling) to come in future iterations[\[16\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L96-L103).

**Permissions & Security:** The extension’s **manifest** is tightly scoped. It requests only the "storage" permission and a single host permission for <https://chatgpt.com/\*[\[39\>]](<https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/manifest.json#L9-L17>). There are **no wildcards** and notably, it does **not include** the usual <https://chat.openai.com/\>* domain – instead it uses chatgpt.com. (This domain resolves to ChatGPT as well, possibly an alternate domain). This choice aligns with the security goal of minimal permissions[\[15\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L44-L51). No content scripts run on other sites, and no external network permissions are declared. The background script explicitly avoids any direct DOM access (and indeed cannot, being a service worker) and performs **no telemetry or external calls** in M1[\[15\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L44-L51). Even when MCP connections are introduced, they will be initiated only to user-specified endpoints and likely via standard WebSocket APIs, not requiring additional permissions. The extension does not include any webRequest or scripting permissions. This minimal approach reduces review friction and ensures user trust: nothing in the extension can run arbitrary code or exfiltrate data beyond its intended MCP interactions. Storage of settings uses Chrome sync such that it is limited (~100KB) and tied to the user’s account (making server config available across their devices, which is convenient and low-risk). All default servers are local or self-hosted (no built-in third-party endpoints), per project rules **“no seeded third-party MCPs”**[\[15\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L44-L51). The initial “Local Echo” server uses a loopback address, so even once connect logic is added, it will only talk to 127.0.0.1 unless the user configures others. Overall, the baseline extension has established a solid secure foundation (Shadow DOM isolation, least privilege perms, clear data separation) on which the upcoming features will build.

## MCP Servers Landscape & Candidates (Docs-Only Survey)

**Goal:** Identify MCP servers that can be run **locally or offline (no cloud credentials)** to integrate as the first real connections. We focus on official Model Context Protocol servers and known community implementations that are stable, open-source, and align with our extension’s needs (JSON-RPC over WebSocket, manageable outputs, permissive licenses). Below is a survey of five candidate MCP servers, with their capabilities, how to run them locally, and integration considerations:

- **1\. Local Echo Server (Dev Test Server):** This is a simple WebSocket JSON-RPC server designed for testing MCP clients. It’s included with the project as scripts/mcp-localdev.js. **Capabilities:** It implements basic MCP RPC methods: initialize (handshake), tools/list (returns a static set of demo tools), and tools/call (executes a tool by name with given arguments)[\[40\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L46-L54). The hard-coded tools are **echo**, **time**, and **sum**[\[41\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L18-L26) – respectively echoing text back, returning the current timestamp, and summing two numbers[\[42\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L54-L63). **Running it:** The script can be run with Node.js (requires the ws package). By default it listens on ws://127.0.0.1:8788[\[43\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L72-L75). For example: node scripts/mcp-localdev.js will start the server (no installation needed aside from Node and npm install ws). There is no authentication or config – it’s intentionally minimal. **Schema:** Tools have straightforward input schemas (echo expects {text:string}, time expects none, sum expects {a:number,b:number})[\[44\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L20-L28) and produce output in the MCP format (e.g., result.content with text). **Maturity:** This is a **development stub**, not meant for production use. It has no external dependencies and almost no error handling. **Fit:** It’s extremely easy to integrate (no special protocol beyond core MCP JSON-RPC) and is already essentially the “Local Echo” server seeded in our extension. It’s ideal for initial integration testing: we can verify that CONNECT_MCP yields the expected three tools and that CALL_MCP_TOOL returns e.g. an echo of the input. **Risks:** Very low – it’s in-process and stateless. The main limitation is that it’s not useful beyond demonstration (doesn’t perform any real external action or long-running task). **Recommendation:** Use Local Echo as the first target for internal testing of the connection flow, but ship a more useful server to users.
- **2\. Memory Server (Knowledge Graph Memory MCP):** The **Memory MCP server** provides a persistent knowledge graph for an AI assistant – essentially a scratchpad memory that can store and retrieve facts, embedding a graph database. **Capabilities:** It supports tools to save information (e.g., memory/save_text to save raw text notes, or memory/save_graph to add entities/relations) and to query or search this stored knowledge (memory/query_text, memory/search_nodes, etc.). It can also recall structured data like timelines or relations between stored entities. The memory is stored locally (by default in a JSON file, or a user-provided path). **Maturity:** This is an _official Model Context Protocol server_, actively maintained by the MCP community. It’s published on NPM as @modelcontextprotocol/server-memory (MIT-licensed). The latest version (2025.8.4) was released in August 2025[\[45\]](https://www.npmjs.com/package/@modelcontextprotocol/server-memory#:~:text=45%2C405), indicating recent updates and stability. It’s widely used in tools like Cursor and Claude Desktop, evidenced by tens of thousands of weekly NPM downloads[\[46\]](https://www.npmjs.com/package/@modelcontextprotocol/server-memory#:~:text=Downloads%20Weekly%20Downloads). **Running it:** Easiest is via NPX – e.g. npx -y @modelcontextprotocol/server-memory. This will fetch and launch the server on a default port (likely 8393 or similar). No API keys are needed; it runs fully locally. Alternatively, a Docker image mcp/memory is provided[\[47\]](https://www.npmjs.com/package/@modelcontextprotocol/server-memory#:~:text=,%7D%20%7D). One can also specify an environment variable for where to save the memory file (e.g., MEMORY_FILE_PATH to choose a custom storage location)[\[48\]](https://www.npmjs.com/package/@modelcontextprotocol/server-memory#:~:text=%22,%7D%20%7D%20%7D). After launch, the server listens for WebSocket connections and implements the standard MCP RPCs. **Tool Schema:** Tools generally use a prefix “memory/…”. For example, as noted in our design docs, the server likely provides memory/save (to save a snippet of text or data into memory) and memory/query (to retrieve relevant saved info by some key or context)[\[49\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DESIGN.md#L40-L44). Additional tools handle graph-based operations like adding entities/relations, reading the whole memory graph, searching nodes by name, etc., making this server quite powerful. (For instance, save_text, query_text, save_graph, search_nodes were mentioned in its docs.) The outputs could be text content or structured JSON (for graph queries). **Integration Fit:** Memory server aligns well with our extension’s goal of augmenting ChatGPT – it can serve as a personal long-term memory for the user’s sessions. It communicates over WebSocket with a JSON RPC identical in structure to our dev server (it supports initialize, tools/list, tools/call). The extension can connect to it without special auth or setup beyond running the command. Because it’s local, privacy is maintained (all data stays on the user’s machine)[\[50\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DESIGN.md#L42-L44). **Risks:** It is a heavier server (written in Python or Node with a graph data model under the hood). Resource usage should be modest, but large knowledge graphs might make queries slow or consume memory. Also, the output format might be more complex (graph results) which our UI must display properly (likely as text or summarized). We should test for multiline content handling. Another consideration is that the assistant (ChatGPT) needs prompting to use these tools effectively – but that is out of scope for the extension logic. **Recommendation:** The Memory server is a strong candidate for **first real MCP integration** (Iteration B). It provides clear user value (remembering conversation details, etc.) without external dependencies. We will need to add a server config in our extension (e.g., name: “Memory Server”, address: default localhost:port) and ensure the extension can manage its lifecycle (it might be left running in the background by the user). Documentation should guide users to run it via NPX.
- **3\. Filesystem Server:** The **Filesystem MCP server** allows an AI to interact with the local file system – reading files, writing or modifying them, listing directories, and searching content. **Capabilities:** It exposes a suite of tools like read_file, write_file, list_directory, create_directory, move_file, search_files, and so on[\[51\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=)[\[52\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=,create_directory). Essentially, it can perform file I/O operations within allowed directories. It will only operate in whitelisted paths that the user specifies when starting the server, preventing access to the entire disk by default[\[53\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=). For example, one might allow it ~/Documents/ProjectX and it won’t go beyond. **Maturity:** This is another official MCP server (@modelcontextprotocol/server-filesystem on NPM). It’s under active development – a recent version 2025.8.21 was published just a few days ago (late August 2025, version number suggests year.month.day)[\[54\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=modelcontextprotocol%2Fserver,filesystem)[\[55\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=Last%20publish). This recency means it likely has up-to-date features and bug fixes (e.g., Windows path support improvements, etc.). It’s also MIT-licensed and has multiple contributors[\[56\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=Collaborators), indicating community support. **Running it:** Like others, it can be launched via NPX. For example: npx -y @modelcontextprotocol/server-filesystem "&lt;path1&gt;" "&lt;path2&gt;" .... The paths provided as arguments define the root directories it can access[\[57\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=Note%3A%20The%20server%20will%20only,args)[\[58\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=,filesystem%22%2C%20%22%2FUsers%2Fusername%2FDesktop%22%2C%20%22%2Fpath%2Fto%2Fother%2Fallowed%2Fdir%22). It defaults to a certain port (often 8234 or similar, but we’ll confirm from docs), and listens for WebSocket connections. No auth required; security is purely by path sandboxing. On startup, it prints the allowed directories and waits for connections. **Tool Schema:** The tools map closely to filesystem operations, making them easy to understand. E.g., read_file takes a file path and returns its content (as text, presumably UTF-8)[\[59\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=). write_file takes a path and content string to create/overwrite a file[\[60\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=). There are directory operations: list_directory lists contents (with an indicator of file vs dir)[\[61\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=,list_directory), create_directory, move_file (which can also rename)[\[62\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=,move_file), search_files to recursively find files matching a pattern[\[63\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=,search_files), and get_file_info to retrieve metadata like size, timestamps, and permissions of a file[\[64\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=%2A%20Case,get_file_info). There’s even a tool to list what directories are allowed (list_allowed_directories)[\[65\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=). The tool results may include text content (for read operations) or JSON structures (for file lists or metadata). We should be prepared to present multiline text (file contents) or lists of filenames in our UI. **Integration Fit:** The filesystem server is extremely powerful for users who want their AI assistant to access local files – use cases include reading project files to answer questions, saving conversation logs, or executing code. From our extension’s perspective, it uses the same MCP JSON-RPC protocol, so integration is straightforward. One concern is **performance and quotas**: reading a large file could produce a very large payload. The extension might need to handle chunking or at least not freeze the UI if a 5MB file’s content comes through. Chrome’s message passing might have size limits, though likely okay up to a few MB. We might enforce caution in UI (or truncate output). **Risks:** Allowing file writes/deletions at AI’s behest is potentially dangerous; however, since the user must explicitly run the server with specific allowed paths, they have control. We should clearly communicate in docs the implications. Another risk is platform differences (Windows vs Unix paths); the server appears to support both, but our extension just passes strings through. Also, the filesystem server might be heavier to run (depending on implementation, possibly Node.js with file system libraries). But given its utility, it’s worth supporting. **Recommendation:** Include the Filesystem server as an optional integration (maybe in a later iteration or as an advanced feature). For Iteration B, it could be the _second_ real MCP we support after Memory. It provides complementary functionality: Memory is more knowledge storage, Filesystem is environment access. Prioritize Memory first, then add Filesystem once the connection manager and UI can handle one server reliably (the roadmap indeed suggests Filesystem as a likely supported server). Ensure we have clear UI in the extension’s “Servers” settings to specify the directory arguments (or instruct using command-line with desired paths).
- **4\. Firecrawl MCP Server (Web Scraping):** **Firecrawl** is a specialized MCP server that interfaces with the Firecrawl web scraping API to enable browsing and scraping content from the internet. **Capabilities:** It provides tools such as scrape (fetch a URL and extract content, possibly in structured format), search (perform web searches), and potentially others for crawling multiple pages or taking snapshots. It essentially gives the assistant the ability to **browse the web in real time**, which is hugely powerful (and one of the flagship uses of MCP in tools like Cursor). Firecrawl MCP can handle things like extracting article text, following links, and has built-in rate limiting and retries for robustness[\[66\]](https://github.com/firecrawl/firecrawl-mcp-server#:~:text=Features). **Maturity:** This server is developed by the Firecrawl team and is fairly popular (the GitHub repo has a decent number of stars and active issues)[\[67\]](https://github.com/firecrawl/firecrawl-mcp-server#:~:text=,Security)[\[68\]](https://github.com/firecrawl/firecrawl-mcp-server#:~:text=176%20Commits). It supports both cloud and self-hosted modes, and even Server-Sent Events (SSE) for streaming results[\[69\]](https://github.com/firecrawl/firecrawl-mcp-server#:~:text=,hosted%20support%20%2A%20SSE%20support). However, **it requires an API key for Firecrawl** in most configurations, since it leverages their web scraping service. The typical usage is to set an environment variable FIRECRAWL_API_KEY before launching[\[70\]](https://github.com/firecrawl/firecrawl-mcp-server#:~:text=Running%20with%20npx). **Running it:** Installation is simple via NPX: env FIRECRAWL_API_KEY=fc-&lt;YOUR_KEY&gt; npx -y firecrawl-mcp[\[70\]](https://github.com/firecrawl/firecrawl-mcp-server#:~:text=Running%20with%20npx). Without a key, it likely won’t function (unless there’s a local mode that uses an open-source crawler, which is not clear). The server is Node-based. The user must sign up on firecrawl.dev for an API key (possibly a free tier exists). Once running, it listens for MCP connections. **Tool Schema:** Key tools are often named plainly: e.g., firecrawl/scrape_url, firecrawl/search or sometimes just scrape/search under a Firecrawl category. Input for scrape would be a URL (and perhaps options like depth or format), and it returns extracted text content and possibly a list of links. search takes a query string and returns search result snippets. There might be tools for screenshot or metadata extraction as well. Because Firecrawl can return large amounts of text (web pages) or multiple results, the output could be quite large (the server likely streams via SSE if the client supports it, but our initial integration might just get the final result). **Integration Fit:** Firecrawl opens up use cases like: user asks ChatGPT about current events or a webpage – the assistant via MCP can call Firecrawl to fetch that info. It’s clearly valuable. But there are considerations: **Auth management** (we would need to allow the user to input and store an API key securely, and ensure not to transmit it anywhere except the local server process environment), and **cost/quota** (calls to Firecrawl may incur usage of the API; we should warn users about that). Also, from a technical perspective, the extension connecting to Firecrawl is straightforward (just another WebSocket to localhost if user runs it, or possibly to a remote endpoint if they host it elsewhere). But the extension should not embed any secret; the user must handle the key. Perhaps we allow configuration in the extension’s settings for “Firecrawl server URL” and instruct setting the env var when running it. **Risks:** The dependency on an external service is a big one – network latency, failures if the Firecrawl service is down or the API key is invalid. Additionally, content from the open web might be large or contain unexpected data (need to ensure our UI escapes or limits any HTML/JS, though Firecrawl likely returns plain text or safe formats). From a policy standpoint, web scraping might introduce data the assistant shouldn’t have (but since the user is initiating it, it should be fine). **Recommendation:** Support Firecrawl as an **optional** integration (as indicated in the roadmap Milestone 4)[\[71\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md#L30-L38), but not as the very first server. It can be a marquee feature once basic connections are proven with simpler local servers. We’ll include UI in the “Add Server” form for Firecrawl (with fields for API key perhaps or at least a note that the user must run it with the key). When testing, simulate it with a real key if possible to validate the tools listing (should show tools like “scrape” and “search”) and a sample call. Given Firecrawl’s heavy output, we may implement streaming or at least a loading indicator if responses take long. We must also handle errors such as “403 unauthorized” gracefully (e.g., show error if key is wrong). This server will be a great addition for power users.
- **5\. Puppeteer/Playwright Browser Automation Server:** These servers allow controlling a headless (or actual) browser to navigate pages, click elements, fill forms, and extract information – effectively letting an AI **manipulate a web browser**. Two similar offerings exist: a **Puppeteer MCP server** (Node-based, controlling Chrome) and a **Playwright MCP server** (potentially more cross-browser, sometimes by the community). **Capabilities:** Tools typically include navigate (open a URL), screenshot (capture page or element image), click (click an element by selector), type or fill (enter text into a field), select (choose an option in a dropdown), and evaluate (run arbitrary JS on the page)[\[72\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=Tools)[\[73\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=,puppeteer_hover). The Puppeteer server also provides resource endpoints like console://logs (to fetch browser console logs) and screenshot://&lt;name&gt; (to retrieve images taken)[\[74\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=The%20server%20provides%20access%20to,two%20types%20of%20resources). Essentially, it’s like automating a browser via MCP. **Maturity:** The official Puppeteer MCP server was available (@modelcontextprotocol/server-puppeteer), but notably it has been **deprecated as of mid-2025**[\[75\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=This%20package%20has%20been%20deprecated). This suggests that maintainers might be focusing on a Playwright-based implementation or ran into maintenance issues. Community forks or alternatives exist (the search turned up a community Playwright server by AutomataLabs, and discussions on Reddit about alternatives). The deprecation is a risk sign – integrating something unmaintained could be problematic. However, the concept is proven useful (many users leveraged puppeteer server before). **Running it:** The Puppeteer server could be run with npx -y @modelcontextprotocol/server-puppeteer (which would actually launch a Chrome instance). The documentation indicates that using NPX will open a real browser window (non-headless) unless run in Docker mode for headless[\[76\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=Docker)[\[77\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=NPX). Docker mode uses a headless Chromium image (which might be heavy but avoids requiring Chrome on the host). The Playwright server likely similar: npx @modelcontextprotocol/server-playwright. These require the host to have the appropriate browser binaries or will download them. For example, Puppeteer usually downloads a Chrome driver on first install. **Tool Schema:** We have a partial list from the Puppeteer server docs: tools are prefixed with puppeteer_and include navigate, screenshot, click, hover, fill, select, evaluate[\[72\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=Tools)[\[78\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=). Inputs are things like URL or CSS selector, and results might be simple acknowledgements or resource references. E.g., puppeteer_screenshot returns a content entry with a screenshot://&lt;name&gt; that the client can then retrieve to get the image data; puppeteer_evaluate returns whatever the script evaluation yields (or error). Many actions are idempotent or state-changing on the browser context, not yielding large text, except console logs which might accumulate. **Integration Fit:** Such a server would allow ChatGPT (via our extension) to not only read web content (like Firecrawl does) but actually interact with web apps – for instance, perform a sequence of actions on a page. This could blur the line between our extension and a full automation tool. While extremely powerful, it’s also the most complex to support. From our side, handling it means we might need to handle binary data (images from screenshots – though likely base64 encoded text is returned which we can display or copy). Also, if the server streams events (like live console logs or incremental page loads), we don’t currently have a UI for streaming. Another challenge: launching the server spawns a browser which might conflict if the user is using the same system browser for ChatGPT (though typically it’s separate). Given the deprecation of the official package, if we proceed we might rely on community servers (which might not strictly follow the same protocols or stability). **Risks:** High – this server could be brittle (browser automation often is). There’s the overhead of running it (CPU/RAM usage for a headless browser is non-trivial). Also, from a security perspective, giving an AI control of a browser could have unintended consequences (navigating to malicious pages, though it’s sandboxed in headless mode). This likely should be opt-in and we might warn users. Additionally, compatibility with MV3 service worker: maintaining a long-lived connection to a puppeteer server that is doing work might require careful handling (to not let the service worker sleep mid-operation). **Recommendation:** **Defer integrating Puppeteer/Playwright** until we have solid support for simpler servers. It might be a “phase 3” feature for power users. If/when we do, consider focusing on the Playwright server (if one is maintained) since Puppeteer one is deprecated. Ensure the extension can handle retrieving binary resources (images) – perhaps by converting them to data URLs and embedding or offering a download. For now, we document that automation servers are on the radar, but not officially supported in iteration B. If a user is keen, they can manually add it as a custom server in settings (our extension’s config should allow arbitrary ws URLs), but we won’t guarantee full compatibility yet.

**Summary & Ranking:** For **Iteration B (next milestone)**, we recommend targeting **one local, no-auth server** initially – **Memory Server** is our top choice due to its utility and zero setup beyond running a command. We will also use the included **Local Echo** server for quick end-to-end testing of the connection workflow (since it’s trivial to run and verify tool calls like echo). After that, in subsequent iterations, **Filesystem** (no auth, local) would be next to add, as it’s also straightforward and useful. **Firecrawl** (requires API key) can follow once users have the ability to add servers via settings and we’ve ironed out connection management – this likely corresponds to an iteration after we have at least one successful integration. **Browser automation (Puppeteer/Playwright)** is powerful but currently less urgent and more complex; we can reevaluate once core connectivity, error handling, and UI for tools results are robust. By focusing on Memory and Filesystem first, we cover a broad range of capabilities (information retrieval & storage, and environment interaction) without entangling third-party services or heavy resources. Both are MIT-licensed and actively maintained, making them low-risk dependencies for our users to install and run.

## Connection & Reliability Patterns (MV3-Compliant)

Establishing and maintaining WebSocket connections in a Chrome MV3 extension requires careful design, due to the **ephemeral nature of service workers** (which may suspend when idle) and MV3’s constraints on background processing. Below we outline a robust connection lifecycle for MCP servers, including when to connect/disconnect, how to detect and recover from errors, and how to define a “healthy” connection – all while staying within MV3 best practices.

**When to Connect:** We should use a **lazy on-demand connection strategy** with caching. Rather than connecting to all configured MCP servers at extension startup (which could be wasteful and even impossible if multiple servers are offline), the extension should **connect to a server only when needed**. “Needed” can be defined as: the user enabled the server and either (a) set it as the default active server, meaning the user likely intends to use it, or (b) explicitly initiates an action requiring a connection (e.g. opens the Tools tab for that server or invokes a tool). For example, on extension load or when the user toggles a server to “enabled”, we don’t necessarily connect immediately – we might wait until the user actually tries to list the tools or run something. This avoids unnecessary background activity and respects MV3’s **idle timeout** (keeping no more long-lived connections than necessary). However, once the user does need it, the connection should be established proactively so the first tool call isn’t delayed by connect time. A balanced approach: **connect on first open of the Tools tab or on first tool invocation for a server**, and thereafter keep it alive as long as the extension (service worker) is active or until an inactivity timeout.

**Keeping the Service Worker Alive:** One nuance is that **an open WebSocket can keep the service worker alive**, but we must be careful. Chrome MV3 allows service workers to stay alive if they have pending asynchronous work, which can include open WebSocket/event streams. However, Google’s documentation doesn’t guarantee that an open WebSocket _alone_ will indefinitely prevent termination – if no incoming messages or events occur, the worker might still be considered idle after 5 minutes. To address this, we plan a lightweight **heartbeat mechanism**. This should _not_ be an aggressive ping (which could drain resources or violate MV3 policies), but rather a modest activity to ensure the connection is alive and the worker knows it. There are two options:

- **Server-Initiated Heartbeat:** If the MCP server has a heartbeat or keep-alive (some servers might send periodic ping frames or notifications), we can rely on that. Many WebSocket servers send low-level ping frames which the browser handles without surfacing to JS, but if they send actual JSON RPC “ping” notifications, we could use those.
- **Client-Initiated Heartbeat:** We implement our own periodic ping message. For instance, every _N_ minutes (perhaps 4 minutes, slightly below the 5 min idle threshold), the background could send a JSON-RPC call like {"method":"ping"} (if the server supports a ping method) or even call a no-op tool (some servers might not have ping, but we could call tools/list as a lightweight check).

We propose to implement an **adaptive heartbeat**: only send heartbeats when the service has been idle (no tool calls) for a while and only if at least one connection is open. N = 4 minutes is a safe heartbeat interval (which is infrequent enough to be negligible overhead). If no response to a heartbeat is received, we mark that connection as possibly stale and will attempt a reconnect on the next operation.

Importantly, we avoid any “infinite loop” of rapid pings that would keep the worker alive 24/7, as that defeats MV3’s design. The heartbeat’s purpose is just to extend the life a bit during active usage. If the user is truly idle (not using any tools), we should allow the worker to go to sleep and disconnect gracefully after some time.

**Connection Lifecycle:** Here’s the sequence we envision:

1. **Initiate Connect:** When triggered (user needs the server), create a WebSocket connection to the server’s URL (stored in settings, e.g. ws://127.0.0.1:8788 for Local Echo, or ws://localhost:port for others). Use the Chrome runtime messaging to inform the content script UI that a connection attempt is in progress (we might show a “connecting…” status).
2. **Handshake – initialize:** Upon socket open, immediately send a JSON-RPC request: {"id": 1, "method": "initialize", "params": {...}}. Many MCP servers expect an initialize call as the first interaction – it typically returns serverInfo (name, version, etc.)[\[40\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L46-L54). If the server doesn’t require it, it should harmlessly return an error or empty result, but given all official servers implement this, we’ll do it uniformly. A successful response to initialize is our first criterion for a good connection.
3. **List Tools – tools/list:** Next, send {"id": 2, "method": "tools/list"} to fetch the available tools. This should return an array of tool descriptors (name, description, input schema)[\[79\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L50-L58). If we get this list, we know the server is fully ready. We then cache the tool list in memory (and possibly in chrome.storage.local under a status key) for use in the UI. At this point, we mark the connection status as **“connected”**.
4. **Connection Persistence:** Keep the WebSocket open. The background should store a reference to the socket and the server ID it’s associated with (in a map within mcpManager). All subsequent CALL_MCP_TOOL messages from content (with a target server ID) will be routed to this socket by sending a JSON RPC tools/call message. We maintain an incrementing request counter for JSON-RPC IDs to match responses.
5. **Error Handling:** We categorize errors into:
6. **Connection errors:** Failure to open socket (e.g., refused connection, no server listening). This triggers an immediate error state – the CONNECT_MCP response to content should be { ok: false, error: "Connection failed: &lt;details&gt;" }. The background should log this event (with perhaps the error message, e.g., ECONNREFUSED) and schedule a retry if appropriate.
7. **RPC errors:** The socket opened but an RPC call returned an error in its response (e.g., calling tools/list yields an error because the server requires auth or has none). These we propagate to UI as well – e.g., show no tools and an error message. We might still consider the connection “established” at the socket level, but mark it as **degraded** if essential RPCs fail.
8. **Unexpected closure:** If the WebSocket closes unexpectedly (server crash or network issue), the background should catch the onclose event. We then update status to disconnected and possibly attempt reconnection after a backoff delay.
9. **Tool call errors:** If a particular tools/call returns an error (e.g., invalid input, or tool-specific failure), we simply propagate that as a failure of that call (not of the whole connection). The connection stays open.

For retries/backoff: We will implement an **exponential backoff** for reconnection attempts to a given server. For example, if connection fails or drops, wait 1 second, then 2s, 4s, up to, say, max 30s or 1 min intervals, doubling each time. Stop retrying after a certain count (maybe 5 attempts) or if the user disables the server. The user can also manually trigger reconnection via a UI button (see Developer UX below).

Notably, we will _not_ aggressively keep trying if a server is consistently down – that could keep the service worker alive unnecessarily. Instead, after the max attempts, mark the server as **“offline”** and only try again on user action (or perhaps if the user toggles it off and on, or on clicking reconnect).

We will distinguish between **“unable to connect”** vs **“connected but unhealthy”** states: - Unable to connect (no socket) – likely the server process isn’t running or network error. In this case, CONNECT_MCP returns error and we set status = red (error). - Connected but unhealthy – e.g., got socket but initialize or tools/list errored or timed out. We should close the socket (since without tools list it’s not usable) and treat as a failure as well, advising to check server logs or config. - Connected and healthy – got tools list. Status = green.

A **timeout** for initialize or tools/list responses is important. If no reply in, say, 5 seconds, we abort and error out, assuming something’s wrong (some servers might do heavy init, but 5s is reasonable for local services; maybe allow slightly longer for Firecrawl or web calls). Timeouts ensure we don’t hang the UI waiting indefinitely.

**Definition of “Connected”:** A server is considered definitively **connected (healthy)** when: - The WebSocket connection is open **and** stable. - We have successfully received a response from the server’s initialize call (thus version info) **and** a non-error response from tools/list (even if the list is empty, that’s okay – empty list means the server has no tools available, which for some servers is valid). - Additionally, for extra confidence, we could perform a quick **tool smoke test** after listing tools: if a server provides a trivial diagnostic tool (many have something like an echo or ping method), we can call it immediately once to ensure the request/response cycle works. For example, Local Echo’s “echo” tool or Memory server’s simple query. However, this may be redundant if tools/list succeeded and doesn’t necessarily catch all issues (the first real tool call by the user will be the ultimate test). We might include a smoke test for servers known to be problematic, but generally we accept the connection after tools list. - We capture a timestamp connectedAt when these criteria are met.

From then on, we maintain some runtime stats for monitoring: - lastHeartbeatAt: updated whenever a heartbeat ping is sent or when any message is received (could use this to decide if connection is idle). - lastOkToolCallAt: updated when a tools/call returns successfully. If we start seeing timeouts or repeated failures in tool calls, it might indicate the connection has gone stale (though more likely the issue is with the tool itself, not the connection). - Possibly lastErrorAt and an error message for the last error encountered (to show in UI or logs).

These would be stored per server (e.g., in an object in chrome.storage.local under the status key). For example, status.local-echo = { connected: true, connectedAt: 1694083200000, lastError: null, lastErrorAt: null, lastHeartbeatAt: 1694083500000, lastOkToolCallAt: 1694083505000 }. We will also track an incrementing counter of connection attempts for each server (to implement backoff).

**Disconnection & Cleanup:** Under MV3, we don’t have an explicit event for service worker suspension to run cleanup, but we can handle this implicitly: - If the service worker is about to go idle (no events), ideally we close any open WebSockets to free resources. In practice, if we do nothing, Chrome might terminate the worker and the sockets likely get closed anyway. But being explicit is cleaner. We can use chrome.runtime.onSuspend event to detect imminent suspension (though not guaranteed to fire in all cases). On suspend, iterate through any open connections and gracefully close them (sending a JSON-RPC shutdown method if one exists, or just closing the socket). - The next time the user needs the server (wakes the extension), we reconnect from scratch. Because our design does not rely on persistent background, this is acceptable. The slight downside is that if the user expects the connection to stay alive in the background (for immediate tool use even after long idle), they might have to wait ~1s for reconnect next time. This is a trade-off to live with in MV3. - We will also provide an explicit **“Disconnect”** or toggle in the UI (for example if a user knows they are done with a server session, or want to reset it). Toggling a server to “disabled” in the UI should immediately drop any open connection and cancel retries.

**Backoff and Retry Strategy:** For reconnection attempts after failure, the algorithm: - First failure: wait 1 second, try again. - If fails again, wait 2 seconds, try again. - Then 4s, 8s, etc., up to, say, 30s or 60s max interval. - If after (for example) 5 attempts (total ~ <2 minutes) it’s still failing, give up and mark the server as _offline_. At this point we stop trying automatically. - The user can manually retry via a “Reconnect” button in the UI, which would reset the backoff and try immediately. - Also, any manual action like toggling the server off and on, or pressing connect, will override and attempt again. - This prevents runaway background loops and respects that if a server isn’t available (e.g., user didn’t start it), we’re not hogging resources.

**Error Taxonomy & Logging:** We will define error codes/messages for common scenarios: - “Connection refused” (server not running or wrong port). - “Timeout” (no response to init or tool in X seconds). - “Protocol error” (malformed response or unexpected data). - “Server error: &lt;message&gt;” (if server returned an error object with code/message). - “Disconnected” (if socket closed normally or by server).

These will be logged via our appendLog utility with level warn or error as appropriate, and also passed to the content script to possibly display in the Dev tab.

Each request we send to background (CONNECT, CALL, etc.) already carries a requestId, and our background responses include that ID and either result or error[\[80\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background.js#L10-L18)[\[81\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background.js#L12-L19). We will extend that by including maybe a correlation ID for internal logs: e.g., when a user triggers CALL_MCP_TOOL (with our own requestId), we can tag the logs of the low-level JSON-RPC request/response with that ID for easier trace. Possibly just logging as meta: { requestId: "...", jsonRpcId: 42, tool: "echo" } on send and response. This will allow the Dev tab to group or filter logs by high-level actions.

**Storage Schema for Status and Logs:** To persist these statuses, we propose a structured key in chrome.storage.local: - Key: mcp.webbridge.status.v1 with value as an object: { "&lt;serverId&gt;": { connected: bool, status: "connected"|"disconnected"|"error", lastConnectAt: number, lastDisconnectAt: number, lastError: string, lastErrorAt: number, lastHeartbeatAt: number, lastOkToolCallAt: number } , ... }. - We may also store the list of tools for each server here (for quick access on UI load without needing to reconnect immediately). E.g., { ..., tools: \[{name, description, inputSchema}, ...\] }. However, tool definitions could be large (especially if there are many tools or big schemas), and storing them could approach local storage quota if not careful. But typically, a server might have on the order of 5-20 tools, which is fine. We can cache them in memory and only store minimal info like tool names in local storage if needed. - Key: mcp.webbridge.logs.v1 is already an array of log entries. We’ll ensure each log entry includes a short context, e.g. which server or which request it pertains to. We might cap this at 500 entries as planned. Each entry is maybe ~few hundred bytes JSON at most (timestamp, level, msg, meta), so 500 entries is easily within the ~5MB local storage limit (actually 500 \* 200 bytes ~ 100KB). - We also have mcp.webbridge.installedAt in local (set on install) to know age of extension.

By using a single key for status and one for logs, we limit the number of writes (each log append rewrites the whole log array – which is fine for a few hundred entries). We should be aware of Chrome’s rate limiting: writing to storage too frequently can be throttled (max ~10 writes/min to avoid). Our logging should be moderated (not every heartbeat ping logged, for instance). We’ll log connection and error events, and maybe tool calls at info level. Heartbeats might only log at a debug level (and perhaps debug logs can be enabled via a setting if needed).

**MV3 Constraints & Solutions:** MV3 disallows long-running scripts outside user-triggered events. Our approach ensures we only actively work when triggered by a message or a socket event. The WebSocket itself operates asynchronously. If a message arrives on the socket (like a tool result or a server push message), that is an event that wakes the service worker, so we can handle it (and that will keep the worker alive until we finish handling the message). The heartbeat timer is a slight challenge: setTimeout or setInterval may not keep a worker alive once no other events are pending. To implement heartbeats, we might schedule the next heartbeat right after sending one (i.e., schedule a timeout at the moment an event occurs). If the worker goes to sleep in between, the timeout might not fire until it wakes again or at all. Chrome might defer timeouts in an idle worker. Therefore, heartbeats might not fire if the worker is completely idle – but if it’s idle, we likely don’t need a heartbeat except to keep it alive, which is a Catch-22. A known trick is to use chrome.alarms API (which is allowed in MV3) to schedule wake-ups. However, we haven’t declared the alarms permission in our manifest. We could consider adding "alarms" permission (which is low-impact and not scary to users) to schedule a heartbeat alarm every few minutes when a connection is open. This would wake the worker to send a ping. If we want to avoid new permissions, we can attempt to rely on occasional incoming data or user events. Many MCP servers might not send unsolicited messages, so alarms could be the more robust solution for long-term stability.

**Idle Timeout & Auto-Disconnect:** We should implement an **auto-disconnect** after a long period of no usage. For instance, if a connection has been open for, say, 10 minutes with no tool calls and only heartbeats, perhaps it's safe to close it to let the worker sleep. The user likely isn’t actively using it. We can make this duration configurable or at least fixed to something reasonable (maybe 15 minutes). This prevents the extension from needlessly keeping resources alive. When auto-disconnect triggers, update status to disconnected (but leave the server enabled in settings). Next time the user tries to use it, a new connect will happen transparently.

**In summary**, our MV3-friendly connection pattern is: - **Lazy Connect on Demand**, - **Verify with initialize & tools/list** (and maybe a quick echo test), - **Maintain with modest heartbeats or by user activity**, - **Detect and log errors**, - **Exponential backoff retries**, - **Graceful close on inactivity or suspend**, - **Stateless reconnection** when needed again.

This approach ensures we meet the “no silent failures” rule (errors always surface via logs or UI) and “no infinite background loops” rule (we won’t spin indefinitely – backoff and auto-shutdown logic cover that). It aligns with MV3’s service worker lifecycle by not requiring persistent execution beyond what open WebSockets naturally allow and user-driven events.

## Developer Experience & UI Signals

To make the extension’s operation transparent and debuggable (especially for developers and power users), we will introduce several **visible signals in the UI** indicating connection status, errors, and activity. The goal is to provide clear feedback (without clutter) so users know when a server is connected or if something went wrong, and to offer tools for diagnostics (like a Dev tab with logs). All of this must blend into the ChatGPT UI in a minimal, non-intrusive way.

**Server List Status Indicators:** In the **Servers tab** (the sidebar list of servers), we will add a small colored indicator (dot or icon) next to each server name to show its current status: - **Gray** – Inactive/Disabled. If a server’s toggle is off, or it’s enabled but not connected yet, show gray. Gray indicates “not connected, not in use.” - **Yellow** – Connecting. When the user enables a server or otherwise triggers a connection, while the handshake is in progress, show a yellow dot (meaning “in progress”). This gives immediate feedback that something is happening. If connection succeeds, it will turn green; if it fails, it will turn red. - **Green** – Connected/OK. The server is enabled and we have an active healthy connection (tools listed successfully, no errors). This tells the user the bridge to that server is up. We might additionally use the green indicator as a button – clicking it could show a tooltip “Connection healthy. Click to disconnect” or something along those lines (not essential, but could be a quick control). - **Red** – Error. This could mean either we attempted connection and it failed, or it was connected but encountered an error/closed unexpectedly. A red dot signals the server is not currently functional. We will likely accompany this with an _error icon_ or tooltip to differentiate from simply disabled (gray). Perhaps a red exclamation mark icon could appear next to the server name in addition to the dot, or the dot itself could have a “!” overlay. The tooltip could say “Error: last attempt failed. Hover for details.” When hovered or clicked, we might show the last error message (e.g., “Connection refused” or “Timeout during tools list”). This helps the user troubleshoot quickly.

These status indicators will update in real-time as events occur. The content script, upon receiving responses from background (which include ok or error), can determine whether to switch a given server’s indicator. Additionally, the background can send explicit status update messages (e.g., a new message type like SAVE_STATUS) whenever something changes, which the content script handles to refresh the UI[\[82\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L26-L34). For performance, we could batch updates (but likely not needed; number of servers is small).

**Badge Text and Icon:** For an at-a-glance indicator without opening the sidebar, we can utilize the extension’s **browser action badge**. The badge is a tiny text over the extension icon. We propose: - When all is well and at least one server connected, maybe show a small green dot or checkmark as the icon badge (Chrome’s badge API only supports text and background color, not an image, so we might not do this unless we use a colored Unicode character). Alternatively, we leave it blank on success to keep it clean. - When there’s an error or a server that failed to connect, use the badge to signal it. For example, show “!” or “Err” with a red background on the icon. This would catch the developer’s eye that something needs attention even if the sidebar isn’t open. Once the error is resolved (or user toggles off that server), we clear the badge. - Another idea is to show the number of connected servers as the badge text (e.g., “1” in green if one is connected, “0” or blank if none). But since typically a user might only use one at a time, that’s less informative. The error bang seems more useful.

We have to be careful: badges are small and Chrome might not show a long text. “Err” or “!” are short enough. We also shouldn’t constantly flip it (it can be distracting). So likely: set badge on first error occurrence, and clear when the user opens the UI or toggles the server (acknowledging it). This is akin to an unread indicator. The roadmap does mention using the badge text for error vs ok signals[\[38\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md#L24-L32), so this aligns.

**Toasts/Notifications:** The extension currently doesn’t display any toast messages. We might keep it that way for now to avoid spamming the ChatGPT UI. Instead, we rely on the visual indicators and the Dev tab for details. If a serious issue occurs (like we lost connection while the user was actively using a tool), a small toast could be warranted (“MCP server disconnected.”). But since our audience includes developers, they might prefer checking the Dev tab or logs. We will likely not implement toast notifications in the first iteration of these features (unless user testing suggests it’s needed).

**Developer “Dev” Tab:** We will add a new tab in the sidebar (next to “Servers” and the planned “Tools” tab) called **“Dev”** or “Logs”. This tab is only visible/meaningful to advanced users (but since our target users include developers integrating their own servers, it’s important). The Dev tab will display diagnostic info: - **Logs view:** A scrollable list of recent log entries (pulled from chrome.storage.local logs array). Each entry can show timestamp, level (maybe color-coded, e.g., error in red, warn in yellow, info in normal text), and message. For instance: \[10:30:12\] info: CONNECT_MCP local-echo -> ok or \[10:31:05\] error: CALL_MCP_TOOL (echo) -> Timeout. We might format these neatly. There should be a “Clear logs” button to wipe the log (which calls CLEAR_LOGS message to background to clear the stored array) – acceptance criteria mention this[\[83\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/TASKS.md#L34-L38). - **Connection metrics:** At the top of the Dev tab, we can show a summary of each server’s status and metrics. Possibly a small table: - Server ID/Name, - Status (Connected/Disconnected/Error), - Last Connected (time or “never”), - Last Error (short message and time), - Last Tool called and result status, - Perhaps how long the background worker has been running (though the worker typically runs only when needed).

Example:

Server Status Last OK Last Error  
Local Echo Connected 07:30:10 AM –  
Memory Error – Connect timeout at 07:25:05

This gives context if something is failing repeatedly. - **Manual controls:** We’ll include buttons for specific actions: - **“Reconnect”** next to each server (or a general one that attempts to reconnect the selected server). This triggers the background to force close and re-initiate the connection immediately, bypassing any backoff waiting. Useful after one fixes a server (e.g., starts the server process after forgetting to run it). - **“List tools”** – mainly a dev action to re-fetch tools list from the server (maybe not needed if we always fetch on connect anyway). But could be handy if a server’s available tools change at runtime (some advanced MCP servers allow dynamic tool loading). - **“Smoke Test”** – a button to run a quick tool call for connectivity test (like call echo with “test”). This can verify end-to-end that calls succeed, and the result could be shown in the logs or as a small output. - These controls would correspond to background messages (CONNECT_MCP, LIST_MCP_TOOLS, CALL_MCP_TOOL with a test payload). - We will grey out or hide controls that don’t apply (e.g., if server not connected, “List tools” might trigger a connect first).

- Possibly show the **service worker status**: since in MV3 the service worker can be stopped, we might show something like “Background active since \[time\]” or “Service Worker restarted at \[last start time\]”. Chrome provides an onStartup or we can log when the worker starts (onInstalled vs subsequent activations). This helps developers know if the background was recently restarted (which could explain a lost connection).

The Dev tab thus serves as both a mini-dashboard and a log console. We will keep it simple text-wise (no fancy charts). It’s mostly for debugging, so being a bit raw is okay.

**User-Facing vs Developer-Facing Elements:** The Servers and Tools tabs are user-facing (for everyday use of tools). The Dev tab and badge indicators are more for the developer/power user to diagnose issues. We want to ensure that an average user (who might just run one server with guidance) isn’t overwhelmed. By default, they might ignore the Dev tab entirely until something isn’t working. The color dot next to server name is understandable at a glance (like status lights). If something’s red, the user knows to check the Dev tab or logs.

**ChatGPT UI Integration Considerations:** Our injected UI should remain subtle. The chip is already an entry point. We might consider making the chip itself reflect overall status: - For instance, if any server is connected and okay, maybe the chip text “MCP” could be in normal color; if there’s an error, perhaps color it red or add a tiny warning badge on it. This way even without opening the sidebar, there’s a hint. However, we must be careful not to break the style (perhaps a small exclamation badge on the chip would suffice). - Alternatively, the extension icon badge (in Chrome’s toolbar) serves that role externally, and inside the page the user will likely click the chip if they care about using the server.

**Events and Signals Mapping:** To summarize, here is a mapping of key events → UI signals:

| **Event or State** | **UI Signal** | **Details** |
| --- | --- | --- |
| Server toggled Enabled (no connection yet) | Gray dot next to server name; no badge text. | Server is marked enabled in settings but connection not started until needed. Initially remain gray (idle). |
| Connecting to server (in progress) | Yellow dot next to server; perhaps chip icon/badge pulses or shows a spinner (if feasible). | As soon as CONNECT_MCP begins, show yellow. Remove yellow once success or failure. |
| Connection successful | Green dot next to server name; clear any spinner/badge. | On receiving tools list OK. Also update Dev tab metrics (connectedAt time). |
| Connection failed (error) | Red dot next to server name; extension icon badge “❗” (red). | Also possibly flash the chip or sidebar to draw attention. Tooltip on red indicator shows error summary. Dev tab logs error. |
| Connection lost unexpectedly (socket closed) | Red dot (if was enabled) and maybe a subtle alert icon on chip. | Also perhaps a transient toast: “Server X disconnected.” We will auto-attempt reconnect (yellow) if appropriate, else leave red. |
| Tool call successful | (No global UI change; maybe briefly highlight the server green or flash the dot?) | We might not need to signal every success – the Tools tab will show the result content. Dev tab can log success. Possibly update a small “last used X sec ago” text in server list. |
| Tool call error (e.g., tool threw) | Maybe turn server dot orange briefly or show an error icon next to the tool result. | The result panel in Tools tab can show the error message to user. We won’t change the overall connection status (since connection is still fine, just the tool failed). Dev tab logs it. |
| Heartbeat timeout detected | (If triggers reconnect) Yellow dot (reconnecting) or Red if giving up. | No direct user action; likely happens if server became unresponsive. Indicate as if connection lost. Dev tab note. |
| User clicks “Reconnect” in Dev | Immediately show yellow dot (connecting) for that server. | Badge cleared if it was error. If succeed -> green, fail -> red again. |
| User clicks “Clear Logs” | Log list empties in Dev tab. | No effect on status indicators. |
| Mutation (SPA navigation) on ChatGPT | Chip re-anchors via MutationObserver, sidebar remains accessible. | (This is more of an internal event – our MO already handles this[\[30\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L176-L184). No explicit signal needed beyond the chip staying visible.) |
| Service worker restarted (extension became inactive and then active again) | Possibly all server dots turn gray (since connections dropped). Maybe a one-time info toast: “MCP extension reloaded, reconnecting...” | We can detect this by storage or a fresh global context. We will auto-reconnect enabled servers if they were connected before, or simply wait for user action. Dev tab could show “Background restarted at HH:MM:SS”. |

This mapping ensures that for every meaningful event, the user or developer has some feedback. Especially error cases are clearly surfaced (red indicators, badges, logs), and normal operation is indicated (green when connected, no news is good news if disabled/gray).

We will implement these signals in a lightweight way: likely by modifying CSS classes on elements in content script (for dots), setting the extension badge via chrome.action.setBadgeText and setBadgeBackgroundColor, and updating the Dev tab HTML.

**Minimalism and Consistency:** We will keep the color scheme consistent with intuitive meanings (green = good, red = bad, yellow = in progress, gray = off). These colors should also match or complement ChatGPT’s dark theme; our CSS variables in the Shadow DOM (already set up for GPT colors[\[84\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L4-L12)) can include these status colors (we might add e.g. --mcp-color-ok: #4ade80 (green), --mcp-color-error: #f87171 (red), --mcp-color-pending: #facc15 (amber) for styling the indicators). For the badge on the extension icon, we are limited to solid background colors – we’ll use red (#FF4136 or similar) for errors; we can consider green (#2ECC40) for OK if we ever show an OK text, but likely we won’t use badge for OK because the absence of error is implicit.

**Example Scenario:** Suppose the user goes to Servers tab and enables “Local Echo”. The dot turns yellow and a second later green as the connection succeeds. The user then goes to the Tools tab (when implemented), runs an Echo tool – result appears, no change in status (stays green). Now they enable “Memory Server” but forget to actually start it in terminal. The dot turns yellow trying to connect, then after a timeout turns red. The extension icon shows “❗”. The user notices and goes to Dev tab, sees an error “Memory: Connection timed out” in logs. They then realize and run npx @modelcontextprotocol/server-memory. Then they click “Reconnect” on Memory in the Dev tab. Dot goes yellow → green now (connected). Badge clears itself. All good. This kind of flow should be smooth and clear with the signals described.

Overall, these developer-visible signals aim to fulfill the acceptance criteria that _“status indicators reflect success/failure”_[\[38\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md#L24-L32) and that _“errors are visible and actionable, with no silent failures”_. By having multi-layer signaling (inline list + dedicated dev console + Chrome badge), we ensure both casual users and developers get feedback appropriate to their needs.

## Roadmap & Milestones (Iteration B & Beyond)

With the baseline in place and research findings above, we propose a refined **roadmap** focusing on delivering one real MCP integration in the next iteration (Iteration B), followed by incremental enhancements. Each milestone is designed to add a coherent set of features with clear acceptance criteria and minimal regression risk. Below is the prioritized plan:

### **Milestone B1: MCP Connection & Basic Tools Integration**

_Objective:_ Introduce the ability to connect to a local MCP server and use its tools, delivering end-to-end functionality for at least one server (Local Echo for demonstration, and Memory Server for real usage) without breaking existing core stability.

- **Scope:** Implement the **MCP Connection Manager** in the background, support CONNECT_MCP, LIST_MCP_TOOLS, and CALL_MCP_TOOL messages, and update the content script to display available tools and tool results.
- **Key Features:**
- Establish WebSocket connection for the default server or selected server when user initiates (toggle on or open Tools tab).
- Retrieve and display the list of tools in a new **“Tools” tab** in the sidebar UI.
- Allow the user to invoke a tool by filling parameters and clicking a “Run” button, then display the result within the UI.
- Basic error handling for connection and tool invocation (e.g., show an error message in UI if connection fails or tool returns error).
- **Acceptance Criteria:**
- _Connect and List Tools:_ When the user enables the **Local Echo** server and clicks “Connect” (if such a control exists, or implicitly when opening Tools tab), the extension successfully connects (handshake) and the “Tools” tab populates with the three demo tools (Echo, Time, Sum) from Local Echo[\[41\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L18-L26)[\[79\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L50-L58).
  - If the local echo server is not running, the user is shown a clear error (e.g., red status dot and an error message “Could not connect to server”). The error is logged in Dev tab.
- _Call Tool Success:_ After connecting, the user can select the **Echo** tool, enter text “Hello”, click “Run”, and the result “Hello” (echoed back) appears in the Tools tab UI within 2 seconds. Similarly, the **Time** tool returns a timestamp string, and **Sum** returns the correct sum. The UI displays results in a readable format (text content is shown, or for structured content, a reasonable rendering).
- _Call Tool Error:_ Induce an error (e.g., call Sum without providing both a and b). The extension should display the error returned by the server (e.g., “Missing parameter”) in the UI, and not crash. The error should also be logged. The connection should remain active after a tool error.
- _Memory Server Integration:_ Through either default config or after user adds it, the **Memory Server** can be connected similarly. Run npx @modelcontextprotocol/server-memory externally, add a server entry in extension settings (address, etc.), enable it. Upon connect, tools like memory/save and memory/query (exact names may vary) are listed. As a smoke test, the user can save a short text and query it back:
  - E.g., use a memory/save_text tool to save “Paris is the capital of France.” (if such a tool exists).
  - Then use memory/query_text with query “capital of France” and receive a result that includes “Paris…” from the memory.
  - Acceptance is that the call returns a plausible result (even if just confirming saved, depending on server implementation), proving that a non-trivial server works.
- _No Regression in Core UI:_ ChatGPT interface remains usable – our UI does not interfere with sending messages. The MCP UI can be toggled closed, and it remembers the server enabled state on reload (since stored in sync storage).
- _Service Worker Lifecycle:_ Test that if the background service worker stops (e.g., by being idle or via manual reload in chrome://extensions), it can reconnect when needed:
  - After a manual SW restart, the next attempt to use a tool triggers a new connection sequence transparently.
  - If a connection was open and worker restarts, the UI should reflect a disconnected state (likely by having to reconnect). There should be no orphaned state in content script.
- **Rollback Plan:** These features are somewhat core, but if issues arise (e.g., unstable connections), we can disable MCP connect functionality via a feature flag (in settings) and default it off, essentially reverting to read-only mode until fixed. Because this is a major addition, thorough testing will precede enabling it by default.
- **Risks:** Reconnecting logic might be tricky; ensure no memory leaks (sockets properly closed). Also large tool results might overwhelm UI – we will set practical limits or pagination if needed (not necessarily in this milestone, but keep an eye).
- **Time Estimate:** This is a big milestone – likely the largest chunk. We anticipate it might need the bulk of the iteration to implement and test.

### **Milestone B2: Enhanced Reliability & Status Feedback**

_Objective:_ Build on the basic connection to add the reliability features (heartbeats, auto-reconnect, robust error handling) and implement the **status indicators and Dev tools** for transparency.

- **Scope:** Introduce the connection management refinements and developer-facing UI improvements described in sections above.
- **Key Features:**
- Heartbeat/keep-alive mechanism to maintain connections during active use, with a strategy to avoid MV3 idle shutdown (may include requesting the alarms permission if needed, with user communication about the change).
- Auto-reconnect with backoff on connection loss.
- **Status Dots** in the Servers list for each server (gray/yellow/green/red as defined).
- **Extension Badge** error indicator.
- **Dev Tab** in the sidebar with log viewer and actions (Reconnect, Clear Logs, etc.).
- Logging enhancements (bound size, include connection events).
- **Acceptance Criteria:**
- _Status Indicators Work:_ Simulate a common scenario – user tries to connect to a server that is down:
  - Enable a server (e.g., Memory but not running). Servers tab shows yellow dot for ~few seconds, then turns red on failure[\[70\]](https://github.com/firecrawl/firecrawl-mcp-server#:~:text=Running%20with%20npx). The extension toolbar icon shows a red “!” badge.
  - Start the server process, click “Reconnect” in Dev tab, dot goes yellow -> green, badge clears. Dev tab logs show the sequence (“Attempt 1 failed… reconnect successful”).
  - When connected (green), if the user stops the server process unexpectedly, within ~heartbeat interval the dot turns red and maybe a small notification icon appears on the MCP chip. The logs show “Disconnected” and error details.
- _Heartbeat & Idle:_ Establish a connection, then do nothing for >5 minutes. Confirm via logging that a heartbeat was sent around the 4-minute mark (Dev tab log should have an entry like “\[debug\] Heartbeat ping”). The service worker should stay alive at least until that point. If the extension still goes idle, it should reconnect when woken:
  - E.g., after ~10 minutes of no use, try a tool; it might need to reconnect (which should happen quickly and succeed).
  - This is harder to manually test, but we’ll simulate lowering the idle time for testing or watch the background console timestamps to ensure heartbeats occur.
- _Dev Tab Log & Actions:_ The Dev tab should list logs (info, warn, error). Trigger various events: connect success (info), connect failure (error), tool call (info), tool error (warn/error) and see them appear. Use “Clear Logs” and verify the list clears and chrome.storage.local logs array is empty (perhaps check via DevTools console).
  - Also test log bounding: push >500 log entries (we might script this in a test build), then check that only the last 500 remain (older ones dropped).
  - Check that no sensitive info (like API keys) is logged by accident.
- _Status Persistence:_ The mcp.webbridge.status.v1 object in storage should update appropriately:
  - After a connect, status\[serverId\].connected is true.
  - After a disconnect or failure, it’s false and lastError is set.
  - These status values should persist across extension restarts (for debugging history), or we decide to clear on restart – to be determined. Likely we keep last known status until a new attempt.
- _No New Permissions w/o Notice:_ If we add "alarms" permission, verify it’s listed and the extension still only has minimal permissions (storage, host, and alarms). If alarms is not added, confirm our heartbeats still function acceptably (this might be a decision: if we can manage without alarms, we will, to avoid expanding permissions).
- **Rollback Plan:** If any of these reliability features misbehave (say heartbeats causing issues), we can disable just those parts via flags. The core connect functionality from B1 would remain. For instance, we could turn off heartbeat pings and accept that connections might drop on idle as a short-term rollback, or disable badge setting if it causes any performance issue.
- **Risks:** Over-engineering could complicate things; we must test in real Chrome environment thoroughly (including maybe on Windows vs Mac for path differences in FS server etc.). Logging too much could hit performance, but 500 entries is fine. We should also ensure thread safety – Chrome message events are single-threaded but our asynchronous flows (socket events) need careful state handling (we might use a small state machine in code to track connecting/connected/disconnecting to avoid race conditions).

_(Milestone B1 and B2 together correspond to Roadmap Milestones 2 and 3, delivering a functional connection manager and tools UI with status)_[_\[85\]_](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md#L15-L23)[_\[38\]_](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md#L24-L32)_. We anticipate these will be the focus of Iteration B (likely needing the full cycle to implement and stabilize)._

### **Milestone C1: Additional MCP Integrations (Filesystem, etc.)**

_Objective:_ Expand the utility by adding support for another major MCP server (Filesystem) and make the server management more flexible for users.

- **Scope:** Introduce the ability for users to add/remove custom MCP server configurations (with address and options) via a **Settings UI**, and include a pre-defined entry or template for the Filesystem server. Also, integrate the Filesystem server’s capabilities into the Tools UI.
- **Key Features:**
- **Settings Tab UI:** A new tab where users can input new server info: e.g., fields for “Server Name”, “Server Address (ws://…)”, maybe “Description”, and default enabled toggle. Validate input (ensure proper ws:// format, non-empty ID).
- Ability to remove a server from the list (except perhaps the built-in Local Echo unless we allow removing it too).
- The Servers list and sync storage update accordingly when servers are added/removed.
- Include a default template for Filesystem server: possibly a button “Add Local Filesystem Server” which pre-fills ws://127.0.0.1:**port** and an appropriate name/description, instructing the user how to run it (we can’t auto-run it, but can guide).
- Testing the Filesystem server end-to-end: connect and call a file read, etc., displaying result.
- **Acceptance Criteria:**
- _Add/Remove Server:_ In the Settings UI, the user can add a new server. For example, add “Filesystem” with address “ws://127.0.0.1:8234”. After saving:
  - The Servers tab immediately shows the new entry with correct name, and it’s persisted in chrome.storage.sync (verify via console that the servers array contains it)[\[86\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/TASKS.md#L42-L49).
  - The user can then toggle it enabled and connect. If the actual server isn’t running, it should behave as usual (yellow->red status).
  - The user can remove a server via a “delete” button in Settings; confirm it disappears from Servers list and storage, and any open connection to it is closed.
- _Filesystem Integration:_ After adding and running the Filesystem MCP (user runs npx ...server-filesystem /some/path), the extension connects (green status) and Tools tab lists file operations (read_file, etc.). The user performs a simple test: read a small text file (ensuring the path is within allowed directories).
  - The file content appears in the Tools tab output, properly formatted (likely just plain text).
  - Write a test file: using write_file tool to create a new file. Then read it back to verify content. Acceptance: the file is indeed created on disk with correct content, and read_file returns that content.
  - Try an operation with intentional error (e.g., read_file with path not allowed) and see a graceful error.
- _Persistence & Defaults:_ The extension should allow marking one server as “default” (this was in baseline functionality with SET_DEFAULT). Ensure that works with multiple servers: if default is set, maybe the Tools tab by default shows that server’s tools first. Also ensure on extension load, if a default is set and enabled, we could auto-connect it (this is an optional enhancement; we might still choose lazy connect only on UI interaction).
  - The default server could be visually indicated (maybe a star or label in Servers list). This is mostly for user clarity. Not a hard requirement but nice to have.
- _No UI regression:_ Adding the Settings tab and possibly more entries should not overcrowd the UI. Test on various window sizes. The Shadow DOM CSS might need tweaks for a multi-tab layout (we currently only had Servers tab hardcoded). Ensure tabs are navigable (Servers, Tools, Settings, Dev).
- **Rollback Plan:** If the Settings UI is problematic, we can hide it and fallback to instructing tech-savvy users to manually edit the sync storage (not ideal, so we want to get Settings UI right). The actual integration of Filesystem can be feature-flagged: e.g., do not advertise it until stable.
- **Risks:** Parsing user input for server configs (we must ensure a malicious or incorrect URL doesn’t break things – e.g., disallow non-ws protocols). Also, we must maintain the rule “no seeded third-party MCPs in defaults”[\[15\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L44-L51) – meaning we shouldn’t ship with an API-key requiring server pre-configured. Adding Filesystem is fine (no auth, local). If we pre-add Firecrawl, we should leave it disabled and requiring user to edit to add key, or better, provide a guided template rather than actual entry.
- This milestone aligns with Roadmap Milestone 5 (“Settings and server management”)[\[87\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md#L39-L46).

### **Milestone C2: Firecrawl & Advanced Use-Cases**

_Objective:_ Optionally (if demand and time permit) integrate a third-party powered server (Firecrawl) and ensure the extension can support those use cases, plus finalize any remaining Dev/QA features.

- **Scope:** Add configuration support for Firecrawl MCP server (including storing an API key securely, if possible), and implement any special handling needed (like streaming output or large results). Also finalize the Dev tab metrics and any automated testing scaffolds (maybe a headless test or an Agent script to validate installation).
- **Acceptance Criteria (abridged, since this is optional):**
- User can add Firecrawl server config, including their API key (perhaps the extension doesn’t store the key in plain text but user can input each time, or we at least warn them it’s stored in sync which is somewhat secure).
- Connecting uses the key (we might have to set an env if launching via command – but since our extension doesn’t launch servers, the user launches it with key; so maybe no special code, just documentation).
- Tools like scrape_page and search_web appear. Calling them returns data (e.g., scrape returns text content of a URL). The extension displays it (maybe truncated if very long, or maybe in a scroll box).
- We handle partial results or stream by either waiting for final result (if server buffers) or implementing streaming UI later.
- Also ensure any permissions needed (if Firecrawl tries to open browser or such – but it doesn’t, it’s just network calls) are handled by the server itself, not our extension.
- Additionally, incorporate final **Dev & QA utilities**: e.g., an automated check accessible in Dev tab “Run self-test” that does a quick round of connecting to Local Echo and calling echo, then reports success/failure.
- Possibly deliver a basic integration test script (outside extension) for maintainers (like using Puppeteer to open ChatGPT with extension and simulate a workflow – this could be mentioned in docs but not part of extension code).
- This milestone corresponds to Roadmap Milestone 4 (Firecrawl integration)[\[71\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md#L30-L38) and Milestone 6 (Dev/QA utilities)[\[88\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md#L46-L52).
- **Risks:** Firecrawl integration might expose any performance issues with large outputs. We must ensure not to freeze the UI if a large HTML is returned – maybe implement loading indicator and incremental rendering if needed (though perhaps not in initial version). Also, storing API keys is sensitive; maybe we decide not to store it at all – user just runs the server with env var, so our extension doesn’t need to know the key, it just connects to ws://localhost:port. That’s simpler and avoids security questions.

**Milestone Planning Summary:**

- **Iteration B (next release)**: Focus on Milestone B1 and B2 – **Core connection functionality, Tools UI, and reliability improvements**. Success = user can connect to at least one local server, run a tool, see the result, and have clear feedback. This brings the extension from a passive shell to a functional bridge.
- **Iteration C**: Build on that with **Settings UI and more servers (Filesystem)**, plus polish (Dev tab, etc.). Possibly Firecrawl if low-hanging fruit or high demand.
- Further iterations could include UI improvements (inserting content into ChatGPT input with one click as mentioned in tasks)[\[89\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/TASKS.md#L46-L53), and more servers or even telemetry-free usage tracking (if we wanted to anonymously count usage, but per rules we won’t do telemetry). Also maybe packaging for Chrome Web Store release.

**Acceptance Tests & Agents:** To ensure each milestone’s stability, we define some tests (some manual, some automated): - _Agent-conn:_ A script or test procedure to simulate connecting to each server and verifying response. For example, an automated test might use a dummy ChatGPT page with our extension loaded, programmatically toggle a server and inspect that the tools list populates. Or simpler, a manual checklist: “Start Local Echo -> enable in extension -> see green dot -> run echo -> got correct result”. - _Agent-health:_ We could create a small background test agent in the extension that periodically calls PING (if we implement a ping message) or monitors that all enabled servers have had a successful heartbeat in the last interval. This could surface as a “Health OK” vs “Health issues” in the Dev tab. For now, this can be manual: developer checks that Dev tab shows expected heartbeat timestamps and no recent errors. - _Agent-dom:_ This would verify the UI persistence: e.g., after navigation events or page refresh, confirm the MCP chip is present and interactive. We can automate this with a Puppeteer script controlling the browser: navigate to chat.openai.com, look for #mcp-webbridge-root in DOM after extension loads, ensure it’s there after various actions. We’ll prepare such a checklist. - _Outputs to prove stability:_ For each test, logs or screenshots can be collected. For example, for agent-conn, we expect in logs something like “Connected to Local Echo (v0.1.0) – 3 tools available” which proves success. For agent-dom, a screenshot of the chip visible after navigation could be taken.

We will set up these as part of Milestone C2 perhaps, or at least document them for manual QA.

**Permissions Revisited:** The plan above **does not require any new host permissions** (we still only interact with localhost or user-provided addresses via WebSocket – those don’t require manifest host permissions because the WebSocket is initiated from background JS, which is allowed to connect anywhere by default as long as the extension isn’t blocked by Chrome’s external request rules. Actually, Chrome extensions can generally make WebSocket/fetch requests to any endpoint unless blocked by CORS; we might need to ensure our outgoing requests are not blocked. If connecting to ws://localhost, it should be fine. If a user put a remote URL (e.g. ws://somecloud.com), CORS might not apply to WS. Likely fine without additional permissions). We may consider adding the "alarms" permission if we do use the alarms API for heartbeat scheduling. This is low risk, but we should double-check MV3 – I believe alarms does not require a special permission string, it’s available by default to extensions (only “optional_host_permissions” etc. are special). Actually, to use chrome.alarms we might not need to declare it; not sure, but it might be available without listing in manifest. We’ll verify; if needed we add "alarms" to permissions. No other permissions (like notifications for toasts) are needed for now. We explicitly avoid any webRequest or content script on other sites etc.

**Compliance with RULES.md:** All these changes are aligned with our guardrails: - No violation of “logic in background, UI in content” – we maintain that separation. - No new telemetry or unauthorized connections – all MCP connections are user-configured. - No broadened host permissions (just possibly alarms which is benign). - **No seeding third-party servers:** We will include integration for Firecrawl and others only as configuration options, not enabled by default. The extension might ship with a disabled entry or just documentation on how to add it, thus not actively contacting any third-party unless user initiates. - We’ll update documentation (README, etc.) accordingly at each milestone.

Finally, each milestone will have a **rollback plan**: If, say, after releasing Milestone B we find an issue (like memory leak or crashes), we can push an update that disables the MCP connection features (maybe by making the UI hide the Tools tab or forcing servers to disabled). Since this is an extension, quick patch releases are possible. However, by thorough testing (with local servers on multiple OS, and maybe a beta release to a small group), we aim to avoid rollback.

**Milestone Checklist (summary):** - Milestone B1: Connect & Tools – _Checklist:_ Connect to dev server, list tools, call each successfully; connect to memory server, basic save/query; ensure no UI freeze or errors. - Milestone B2: Reliability & Status – _Checklist:_ Simulate down server error visible; logs appear; heartbeat keeps connection alive 5+ min (observed via timestamps); disconnect recovery works. - Milestone C1: Settings & Filesystem – _Checklist:_ Add new server config persists; Filesystem read/write tested; multiple servers default handling; UI layout with new tabs still OK. - Milestone C2: Firecrawl & QA – _Checklist:_ Fetch real webpage content via Firecrawl (if possible in a test env) and display; no crashes on large output; Dev self-tests all pass (perhaps an automated script that does echo test passes).

With this roadmap, **success means** by the end of Iteration B, we have a working extension where a user can connect ChatGPT to, say, a Memory or Filesystem MCP server running on their machine and have ChatGPT effectively utilize that tool. We will have clear signals so if something breaks, the user/developer can figure out why (via status and logs). Iteration C then enriches the configurability and additional tools, making MCP Web Bridge a versatile and robust piece of the AI assistant ecosystem.

**Issues & PRs:** Alongside these milestones, we will open GitHub issues for each task chunk (following our template). For instance: - “Implement CONNECT_MCP and basic WebSocket handling” (linked to Milestone B1) – with sub-tasks and acceptance tests. - “UI: Tools tab and result rendering”, - “Add status indicators in UI”, - “Dev tab and logging UI”, - “Settings form for servers”, - etc. Each will reference relevant design decisions (ensuring none conflict with RULES.md; if any do, we’ll flag and adjust). We will also consider an ADR update if significant decisions (like using alarms or handling API keys) need formal recording.

By following this roadmap, we aim to deliver a **useful, manageable feature set** incrementally, always with a fallback to the previously stable state if needed. The first real MCP server integration will be a major proof point – once that works, adding others is mostly extending config and testing edge cases, as the core bridge logic will be in place.

[\[1\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L10-L19) [\[2\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L18-L26) [\[8\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L22-L29) [\[15\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L44-L51) [\[20\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L30-L38) [\[21\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L34-L42) [\[27\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L38-L46) [\[82\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md#L26-L34) DECISIONS.md

<https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DECISIONS.md>

[\[3\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/router.js#L6-L13) [\[4\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/router.js#L16-L24) [\[5\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/router.js#L32-L40) [\[6\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/router.js#L28-L35) [\[7\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/router.js#L46-L50) [\[18\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/router.js#L34-L42) router.js

<https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/router.js>

[\[9\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L56-L64) [\[11\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L34-L42) [\[12\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L86-L89) [\[13\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L58-L61) [\[16\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L96-L103) [\[19\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L50-L58) [\[32\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md#L64-L73) README.md

<https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/README.md>

[\[10\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DESIGN.md#L46-L54) [\[17\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DESIGN.md#L10-L15) [\[49\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DESIGN.md#L40-L44) [\[50\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DESIGN.md#L42-L44) DESIGN.md

<https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/DESIGN.md>

[\[14\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/log.js#L4-L12) log.js

<https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background/log.js>

[\[22\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L40-L48) [\[23\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L14-L22) [\[24\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L60-L68) [\[25\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L2-L10) [\[26\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L150-L158) [\[28\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L150-L159) [\[29\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L164-L172) [\[30\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L176-L184) [\[31\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L178-L182) [\[33\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L66-L74) [\[34\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L76-L84) [\[35\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L94-L103) [\[36\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L118-L126) [\[37\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L110-L118) [\[84\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js#L4-L12) mount.js

<https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/content/mount.js>

[\[38\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md#L24-L32) [\[71\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md#L30-L38) [\[85\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md#L15-L23) [\[87\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md#L39-L46) [\[88\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md#L46-L52) ROADMAP.md

<https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/ROADMAP.md>

[\[39\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/manifest.json#L9-L17) manifest.json

<https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/manifest.json>

[\[40\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L46-L54) [\[41\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L18-L26) [\[42\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L54-L63) [\[43\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L72-L75) [\[44\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L20-L28) [\[79\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js#L50-L58) mcp-localdev.js

<https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/scripts/mcp-localdev.js>

[\[45\]](https://www.npmjs.com/package/@modelcontextprotocol/server-memory#:~:text=45%2C405) [\[46\]](https://www.npmjs.com/package/@modelcontextprotocol/server-memory#:~:text=Downloads%20Weekly%20Downloads) [\[47\]](https://www.npmjs.com/package/@modelcontextprotocol/server-memory#:~:text=,%7D%20%7D) [\[48\]](https://www.npmjs.com/package/@modelcontextprotocol/server-memory#:~:text=%22,%7D%20%7D%20%7D) @modelcontextprotocol/server-memory - npm

<https://www.npmjs.com/package/@modelcontextprotocol/server-memory>

[\[51\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=) [\[52\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=,create_directory) [\[53\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=) [\[54\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=modelcontextprotocol%2Fserver,filesystem) [\[55\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=Last%20publish) [\[56\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=Collaborators) [\[57\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=Note%3A%20The%20server%20will%20only,args) [\[58\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=,filesystem%22%2C%20%22%2FUsers%2Fusername%2FDesktop%22%2C%20%22%2Fpath%2Fto%2Fother%2Fallowed%2Fdir%22) [\[59\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=) [\[60\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=) [\[61\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=,list_directory) [\[62\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=,move_file) [\[63\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=,search_files) [\[64\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=%2A%20Case,get_file_info) [\[65\]](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2#:~:text=) @modelcontextprotocol/server-filesystem - npm

<https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem/v/0.6.2>

[\[66\]](https://github.com/firecrawl/firecrawl-mcp-server#:~:text=Features) [\[67\]](https://github.com/firecrawl/firecrawl-mcp-server#:~:text=,Security) [\[68\]](https://github.com/firecrawl/firecrawl-mcp-server#:~:text=176%20Commits) [\[69\]](https://github.com/firecrawl/firecrawl-mcp-server#:~:text=,hosted%20support%20%2A%20SSE%20support) [\[70\]](https://github.com/firecrawl/firecrawl-mcp-server#:~:text=Running%20with%20npx) GitHub - firecrawl/firecrawl-mcp-server: Official Firecrawl MCP Server - Adds powerful web scraping to Cursor, Claude and any other LLM clients.

<https://github.com/firecrawl/firecrawl-mcp-server>

[\[72\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=Tools) [\[73\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=,puppeteer_hover) [\[74\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=The%20server%20provides%20access%20to,two%20types%20of%20resources) [\[75\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=This%20package%20has%20been%20deprecated) [\[76\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=Docker) [\[77\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=NPX) [\[78\]](https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer#:~:text=) @modelcontextprotocol/server-puppeteer - npm

<https://www.npmjs.com/package/@modelcontextprotocol/server-puppeteer>

[\[80\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background.js#L10-L18) [\[81\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background.js#L12-L19) background.js

<https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/background.js>

[\[83\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/TASKS.md#L34-L38) [\[86\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/TASKS.md#L42-L49) [\[89\]](https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/TASKS.md#L46-L53) TASKS.md

<https://github.com/jasonshaw0/MCPWebBridge/blob/8526575eed2864f720ee20d23884009d56a7db63/docs/TASKS.md>