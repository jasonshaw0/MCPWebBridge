# Redesign & Bootstrap Plan for MCP Web Bridge Extension

**Background:** The MCP Web Bridge Chrome extension (MV3) currently injects a sidebar UI into ChatGPT’s web interface but provides limited real functionality. The initial implementation focused on UI (a floating “MCP” chip and sidebar with Servers/Tools/Dev/Settings tabs) and basic messaging/storage scaffolding. However, it lacks a robust architecture and fails to deliver meaningful MCP-powered features. The following plan outlines a complete redesign for a sustainable, extensible system, addressing architecture, development practices, and feature roadmap, with reasoning for each decision.

_Figure: Current MCP Web Bridge UI in ChatGPT, showing the injected sidebar with Servers, Tools, Dev, and Settings tabs (Dev tab active). The UI shell is in place, but underlying functionality needs a reboot._

## 1\. Architecture Blueprint

**High-Level Components:** The redesigned extension will be organized into clear modules, each with a single responsibility, to improve maintainability and scalability[\[1\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md#L16-L24)[\[2\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L40-L43):

- **Content Script (UI Layer):** Runs in the context of ChatGPT’s page. Responsible for injecting and managing the UI (floating toggle button and sidebar panel) in an isolated Shadow DOM[\[3\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L8-L10)[\[1\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md#L16-L24). It handles user interactions (button clicks, form inputs) and displays results or statuses. The content script should**not** contain business logic or direct tool code – it will act as a client that sends requests to the background and renders responses.
- **Background Service Worker (Logic & Integration Layer):** Runs separately with extension privileges. It handles all logic, state management, and external communications. This includes managing the list of MCP servers, establishing connections (e.g. WebSocket to local MCP servers), invoking tools, and storing settings/logs[\[4\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L40-L48)[\[5\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L261-L270). The background acts as a controller: it receives structured messages from the content script and returns results or updates after performing the required actions.
- **Storage & Settings Module:** A part of the background (or separate module) dedicated to reading/writing configuration (using chrome.storage). This module defines the data schema for extension settings (like the list of servers, default server, etc.) and handles migration logic when upgrading versions[\[6\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L34-L42)[\[7\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L101-L109). It will expose get/set functions for other parts of the background logic, ensuring a single source of truth for server definitions, enabled/disabled status, and last-known statuses.
- **MCP Connection Manager:** Another background sub-component focused on managing active connections to MCP servers (especially WebSocket servers). This will encapsulate connection state (open sockets, pending RPC calls, etc.) and provide functions to connect/disconnect and call tools. In the current code, this logic exists but is interwoven in the background script[\[8\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L198-L207)[\[9\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L226-L234). The redesign will isolate it (e.g., a class or module) so that the background’s message handler can simply call connectionManager.connect(server) or connectionManager.callTool(server, tool, args). This separation makes it easier to support different server types (WebSocket, HTTP, local stub) consistently.
- **MCP Server Adapters (Future):** In anticipation of supporting non-WebSocket MCP endpoints or integrating more tightly with certain servers, we might design an adapter interface. For example, a WebSocketServerAdapter handles JSON-RPC over WebSocket (used for local development servers and similar), while an HTTPServerAdapter could handle RESTful tool calls if needed (for servers exposed via HTTP endpoints). Initially, we can implement just what we need (likely WebSocket for local servers and perhaps HTTP for simple echo), but having an extensible pattern will ease adding new server types or protocols later.

**Modular Code Layout:** We will move away from a single large file per context (the current iteration has one monolithic content.js and background.js). Instead, use a modular project structure (with ES6 modules or TypeScript) to separate concerns. For example:

- content/ directory for content script code:
- ui.js (or .tsx): code for building the UI components (entry button, sidebar structure, tab switching logic).
- dom.js: utilities for mounting the UI on the page (finding the ChatGPT composer element, handling MutationObserver to remount if needed).
- content-messaging.js: handles sending requests to background and receiving responses (could wrap chrome.runtime.sendMessage with promise-based API).
- background/ directory for service worker code:
- background.js (entry that registers listeners and ties modules together).
- state.js: definition of data models and functions for reading/writing settings (e.g. getSettings, saveSettings, with versioning).
- mcp-manager.js: manages MCP connections and RPC calls.
- handlers.js: the message router that maps incoming message kinds to the appropriate handler function (could be the same as background.js for simplicity, or separate).
- Optionally, separate files for specific feature logic (e.g. logger.js for maintaining logs, if that grows large).
- manifest.json, etc., remain at project root as usual.

Using a build tool (see section 6) with this structure will bundle the files appropriately for MV3. The goal is to make each piece of the system understandable and replaceable. For instance, the UI should be replaceable without affecting how messages are processed, and the MCP connection logic can be modified (e.g., to add streaming support) without touching the UI code.

**Separation of Concerns:** The extension should enforce a strict separation between UI and logic:

- **UI vs Logic:** The content script should purely deal with_presentation_ and user input. It should not contain hard-coded data about servers or implement tool functionality. All it does is request data or actions from the background and display the results. This way, if the ChatGPT page changes or we alter the UI framework, we don’t risk breaking core logic. Likewise, the background should not manipulate the DOM directly – any needed DOM info (like detecting page state) should be gathered by the content script and passed in a message if absolutely required.
- **Messaging (Transport) Layer:** The communication between content and background remains a message-passing interface with defined schemas. The current design already defined an envelope with kind, requestId, etc.[\[10\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L46-L54). We will maintain this, but possibly refine it (e.g. use a TypeScript enum or constant definitions for message kinds to avoid typos, and include more descriptive error fields). Each message type corresponds to a well-defined request (e.g. “LIST_SERVERS” or “CALL_TOOL”) that triggers a single function in the background. The response includes ok and either data or an error. This strict schema avoids ad-hoc or “vague” messages – new message types must be added intentionally and documented. By keeping message patterns consistent, we reduce confusion in how content and background coordinate (preventing the “messy message passing” seen when such boundaries are not clear).
- **Settings Persistence vs Live State:** The extension will distinguish between_persistent configuration_ (what’s stored in chrome.storage and remains across sessions) and_volatile state_ (like current connection statuses or logs held in memory or local storage). For example, the list of servers and their base info is persistent (in chrome.storage.sync as before[\[11\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L42-L50)[\[7\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L101-L109)), whereas the current “connected/disconnected” status or last echo response can be kept in a background variable or chrome.storage.local (as done in current version[\[12\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L70-L78)[\[13\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L100-L108)). This separation was partly implemented (status and logs stored in local storage in the current design[\[12\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L70-L78)[\[14\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L86-L95)); we will continue this pattern. The architecture should allow the UI to request both types: e.g. “LIST_SERVERS” returns the persistent list, “LIST_STATUS” returns a map of runtime statuses[\[15\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L353-L360).
- **Server Integrations (Future-proofing):** The design should account for adding new AI site integrations later. This means isolating any ChatGPT-specific logic. For now, the content script runs only on ChatGPT’s domain, but we might later include matches for other sites or have separate content scripts. To prepare, we can structure the content script such that site-specific elements (selectors, styling adjustments) are in one place. For example, have a small adapter or config for “ChatGPT integration” that knows how to find the message input area and where to inject the UI. If we add another site, we could provide a different adapter for that site’s DOM. In this iteration, focusing on ChatGPT, we’ll at least make the mount logic flexible (e.g., not hard-coding too many ChatGPT CSS specifics beyond what’s needed) and clearly comment any site-specific assumptions.

**Component Interaction Map:** In summary, a typical flow in the new architecture: 1. **User Action:** User clicks “Connect” on a server or hits a “Run Tool” button in the sidebar UI. 2. **Content Script:** The content script captures this event and calls a local function like sendMessage('CONNECT_MCP', {id, url}) or sendMessage('CALL_TOOL', {...}). This uses chrome.runtime.sendMessage to send a structured Message object to the background[\[5\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L261-L270). The UI might also show a loading indicator. 3. **Background:** The background’s message listener dispatches to the appropriate handler (e.g., a function that handles “CONNECT_MCP”)[\[16\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L376-L385). This handler uses the MCP Connection Manager to attempt the connection. Upon success or failure, it updates any relevant state (e.g., mark server as connected, retrieve available tools). 4. **Background Response:** The background sends a response message back with ok: true/false and data (for “CONNECT_MCP”, the list of tools, status, etc.)[\[17\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L380-L388). It may also update stored status or logs internally. 5. **Content Script Receives:** The content script’s promise resolves with the response. It then updates the UI – for example, if ok and tools list are returned, it displays the tools under that server or in the Tools tab; if an error, it might show a toast notification. 6. **Continuous Updates:** If the action was something like toggling a server or setting default, the UI might just refresh its list by requesting updated settings. In all cases, the content script only renders what the background tells it to.

This clean separation means we could even programmatically test the background logic by sending it messages without involving the UI, which is good for future unit testing. The **component map** thus looks like:

- Content UI (Shadow DOM) ←→**Messaging** ←→ Background Handlers → \[Storage, Connection Manager, etc.\] → External MCP servers.

By keeping these links narrow and well-defined, the system becomes easier to extend (e.g., adding a new “REMOVE_SERVER” message type to delete a server entry) without breaking other parts.

## 2\. System Rules & Project Guidelines

To avoid the pitfalls of the first attempt and ensure engineering discipline, we establish a set of project rules. These guide when to be flexible versus when to solidify design, how to use the AI development assistant (Cursor), and how to prevent regressions:

- **“Decide Late” for Unproven Choices:** Follow the practice of deferring irreversible decisions until we have more data[\[18\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=Operating%20rules%20for%20this%20project). For example, if unsure about a UI paradigm or a complex integration, implement the simplest viable option first (that can be reversed), and document alternatives. In practice, this means using feature flags or simple toggles for experimental features and having a rollback plan. The initial iteration applied this (e.g., anchored chip UI with a plan to switch to a different panel if it proved brittle[\[19\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DECISIONS.md#L2-L6)); we will continue this approach for new features. When adding something like streaming output or multi-site support, start behind a flag or in dev mode until proven.
- **Lock Down Core Structure Early:** Conversely, identify the core architecture that should remain stable and lock it down once designed. In this case, the content/background split and message schema are fundamental – we should solidify these now (with TypeScript types or exhaustive documentation) so they don’t keep changing. For instance, define the Message types and ensure all contributors (human or AI) adhere to them when extending functionality. By committing to a stable internal API (between content and background), we prevent “scope creep” where later modifications introduce ad-hoc message kinds or side effects. Each change to this core should require justification and careful testing.
- **Consistent Messaging Contract:** All message types and data structures must be clearly documented and remain consistent. Avoid vague payloads (e.g., no passing large blobs or using one message type for multiple purposes). If a new capability is needed, define a new message kind explicitly. This was somewhat adhered to with the envelope schema in iteration A[\[10\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L46-L54), but as we add more (such as a future “RUN_TOOL_WITH_CONTEXT” or similar), maintain clarity. Each message handler should either return a well-structured success response or a detailed error. No silent failures – log and propagate errors for visibility (which can be viewed in the Dev tab’s logs).
- **Minimal & Explicit Permissions:** Continue the principle of least privilege. The extension should only request the permissions it needs. Currently it uses only storage and host permissions for ChatGPT and localhost[\[20\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/manifest.json#L9-L17). If we integrate new servers or features, be cautious not to add broad permissions. For example, if we allow fetching arbitrary URLs (via a Fetch MCP server), we do that through the server (which might itself fetch), not by giving the extension direct cross-origin powers (unless absolutely necessary). This way, we keep the extension safe and easier to approve if distributing. We also**avoid any user data telemetry** or external calls from the extension itself[\[21\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L60-L64). All network calls should either be to local MCP servers or initiated by the user’s actions (no background tracking). This ensures user trust and aligns with the initial no-telemetry rule[\[21\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L60-L64).
- **Robust DOM Handling:** Because ChatGPT’s web UI is dynamic and subject to change, we set rules for interacting with the page:
- Use**stable selectors** whenever possible (check for data-\* attributes or unique element structures rather than auto-generated classes). In the current snapshot, for example, the composer form has data-type="unified-composer"[\[22\]](file://file-3ZPr3e7BhXfnwbhJc458qs#:~:text=aria,areas%3A%27header_header_header%27_%27primary_prim) – that might be more stable than the classes that could change with each deployment. We will prefer such attributes or roles.
- Implement a**MutationObserver** to detect when critical DOM elements are removed or altered, and re-inject or reposition our UI accordingly[\[23\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md#L23-L31)[\[24\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=match%20at%20L875%20,reapply%20anchor%3B%20window%20resize%20handler). The first version did this by observing the entire document for changes and reapplying the anchor[\[25\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=const%20mo%20%3D%20new%20MutationObserver,window.addEventListener%28%27resize%27%2C%20reapply%29%3B)[\[26\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=const%20mo%20%3D%20new%20MutationObserver,reapply%29%3B). In the redesign, we’ll fine-tune this: for example, observe a specific container (like the element with id thread-bottom that contains the composer[\[27\]](file://file-3ZPr3e7BhXfnwbhJc458qs#:~:text=h,thread)). When a mutation occurs (such as navigating to a new chat or ChatGPT re-rendering the input form), the content script should promptly remount the MCP panel in the new DOM. Also handle window resize events to adjust positioning[\[25\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=const%20mo%20%3D%20new%20MutationObserver,window.addEventListener%28%27resize%27%2C%20reapply%29%3B)[\[28\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=match%20at%20L1068%20,handler%3B%20selectors%20avoid%20brittle%20classnames).
- Use**safe fallback positions** if the dynamic anchoring fails[\[29\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md#L25-L32)[\[30\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md#L38-L44). The previous design chose fixed offsets (e.g., bottom:120px) if the composer wasn’t found[\[31\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=match%20at%20L872%20,documentElement%20to%20reapply%20anchor%3B%20window). We will keep a similar fallback – ensure the MCP toggle button is visible on the page bottom-right even if we can’t find the ideal attach point, so the user can always access it. This prevents the extension from “disappearing” entirely in edge cases.
- _No interference with page_: The Shadow DOM ensures our styles don’t leak[\[3\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L8-L10). We must also avoid injecting any global scripts that conflict with ChatGPT. All our content script code runs in isolation and should be careful if querying or modifying any existing element (prefer to only append our own elements). Never assume constant positions of ChatGPT elements; always recalc if needed – for instance, if ChatGPT introduces a footer or shifts the layout, our code should detect overlaps and adjust (e.g., by altering our bottom offset). These precautions maintain resilience on a dynamic site.
- **Cursor/AI Development Practices:** Since the user will use Cursor (with GPT-4/5) to develop this, establish guidelines to use the AI effectively:
- When using Cursor’s AI to generate code or plans, always**provide the latest context** – e.g., give it this blueprint and the updated design docs to prevent it from reintroducing solved issues. Clearly state the current state and the next goal (we will prepare a prompt handoff in section 7).
- **Iterative Development:** Use a step-by-step approach. For example, first implement the new storage schema and verify it, then the messaging, then the UI, rather than prompting the AI for the entire extension at once. This aligns with breaking down tasks, which can be aided by the Sequential Thinking MCP server (for brainstorming implementation steps).
- **Ask for Alternatives & Justify:** Encourage the AI to suggest 2-3 approaches for tricky decisions (just as we did in iteration A)[\[18\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=Operating%20rules%20for%20this%20project). For instance, if deciding how to display tool results (modal vs inline), have the AI weigh pros/cons. This keeps the human developer in the loop and ensures the chosen path is reasoned about.
- **Verify Environment Assumptions:** One frustration earlier was confusion about using the correct Chrome profile/window for testing the extension[\[32\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=Of%20course%2C%20apologies%20for%20the,with%20logins%20and%20extension%20loading). Make sure the AI doesn’t assume nonexistent conditions. Always verify where the extension is loaded and that ChatGPT is accessible (logged in). If the AI suggests something that doesn’t align with real-world constraints (like opening a new Chrome instance that lacks auth), override that advice. A rule can be:_if the extension isn’t behaving as expected, double-check environment and the extension’s console logs before making code changes_. In other words, use empirical debugging (via DevTools) in conjunction with AI suggestions.
- **Keep Tone Focused and Professional:** When interacting with Cursor’s model, prefer clear, directive prompts. We’ll instruct the AI to avoid excessive apologizing or meandering – prior logs show it apologizing for confusion instead of solving the root issue[\[32\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=Of%20course%2C%20apologies%20for%20the,with%20logins%20and%20extension%20loading). The AI should be guided to focus on technical solutions and factual clarity. We will include tone guidance in the prompt handoff to ensure productive dialogues (e.g., encouraging concise answers, no repetition of solved points).
- **Prevent Regression of Known Issues:** Document all known problems from iteration A and explicitly instruct not to repeat them. For example, if the prior version had an issue where the panel sometimes overlapped the chat input, note that and ensure the new positioning logic accounts for it (perhaps by reading the bounding box of the composer and offsetting above it[\[33\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=,documentElement%20to%20reapply%20anchor%3B%20window)). If message passing was “messy,” enforce that all new message types must be added to a central schema (like a TypeScript type union) to avoid mistakes. Essentially, use lessons learned as requirements. This will be part of the project instructions going forward so that any collaborator (human or AI) is aware.

By adhering to these engineering principles, the project will maintain **high modularity and clarity**, reducing the chance of falling back into a tangle of half-working features. Every component or feature should have a purpose and be built under these constraints, which act as guardrails against the kinds of vague or brittle behavior observed in the earlier attempt.

## 3\. Recommended Features & Methods (MCP-Powered)

To deliver real utility, the extension must go beyond placeholders and demonstrate how MCP servers can enhance ChatGPT usage. Below is a prioritized set of core features for the reboot, each leveraging MCP capabilities:

- **Connect to Real MCP Servers:** Currently, the extension seeds several server entries (Local Dev, Firecrawl, Puppeteer, etc.) but only the local echo server and local WebSocket dev server do anything useful[\[34\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=btnConnect,res.tools%7C%7C%5B%5D%29.length%7D%20tools)[\[35\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=try%20,OK%27%20%3A%20%27%21%27%2C%20color%3A%20isOk). We should enable actual connections for at least one or two powerful servers:
- **Local Dev MCP (WebSocket)** – Keep this for development/testing (as it’s already implemented). It’s useful as a quick connectivity check and can host simple tools (echo, time, sum)[\[36\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/scripts/mcp-localdev.js#L18-L26). We’ll maintain it as a default for now (so new users see something working immediately).
- **Firecrawl Web Scraping MCP** – Integrate the official Firecrawl MCP server to allow fetching web content. Firecrawl is an open-source MCP server specialized for web scraping, searching, and crawling pages[\[37\]](https://docs.firecrawl.dev/mcp-server#:~:text=Features). By connecting to a running Firecrawl server (either self-hosted or the cloud endpoint), the user can input a URL and get content or perform site searches.**Method**: Provide a UI in the extension (perhaps in the Tools tab) to enter a URL or query, then call the Firecrawl server’s firecrawl_scrape or firecrawl_search tool. The result (e.g. scraped text or summary) would be displayed in the panel. This directly addresses a common ChatGPT limitation (no browsing). The extension essentially becomes a bridge that lets the user fetch information and then they can paste it into ChatGPT. For example, if ChatGPT says it cannot access a link, the user can use the extension to fetch that link’s content via Firecrawl and then ask ChatGPT about it.**Implementation**: When the user clicks “Run” on the Firecrawl tool with a URL, the content script sends a CALL_MCP_TOOL message. The background uses the MCP connection to Firecrawl to execute the scrape. On success, we display the retrieved text (perhaps truncated with the option to copy full text to clipboard or insert into the chat input). This feature showcases real web integration – a major value-add.
- **Sequential Thinking (Reasoning)** – Utilize the Sequential Thinking MCP server[\[38\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20Memory%20,Time%20and%20timezone%20conversion%20capabilities) to handle complex multi-step tasks. This server provides tools for structured problem solving (it might break down tasks or generate step-by-step plans). In the ChatGPT context, this could be used to help the user organize their query or project.**Feature idea**: A “Plan my query” function – the user enters a complicated question in a form, the extension calls the sequential thinking tool which returns a structured plan or set of sub-questions. The extension can then present this plan, and perhaps allow the user to send one of the sub-questions to ChatGPT. While somewhat experimental, it demonstrates the MCP’s power to complement an LLM. The UI could integrate this as a special tool where the input is a natural language problem and the output is a list of steps or suggestions. This result can be shown in the Tools tab or a modal. The user then can copy steps into the chat or simply use them as a guide.
- **Memory (Persistent Knowledge Base)** – Integrate the Memory MCP server[\[38\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20Memory%20,Time%20and%20timezone%20conversion%20capabilities) which acts as a knowledge graph memory. This could let the user store information across sessions. For instance, a feature “Save to Memory” to preserve a piece of ChatGPT’s answer or user’s note, and “Recall Memory” to search for saved items. A use case: the user has an important fact from a previous chat – they could highlight it and click “Save to Memory” (perhaps via a context menu or a button in the extension UI). Later, they can query the memory (e.g., “Find the note about X”) and the extension will use the memory server to retrieve it. This result could be inserted back into the chat. This feature emphasizes extensibility: it’s not essential for initial release, but planning for it is worthwhile. The**method** to invoke would be calling memory server tools like memory/save or memory/query (depending on that server’s API). We’d likely need to supply some identifier or let the user label their saved snippets.
- **Enhanced Tool Result Display:** In the current version, when a tool runs, the UI just shows a toast “Tool OK” and logs an event[\[39\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=args%3A%20parsed%20,catch%20%28e%29), but does not display the actual content returned. A crucial improvement is to**present tool outputs to the user**. We will implement a results area in the UI, possibly within the Tools tab or as an expandable section under each server’s listing:
- For example, after running a tool like Firecrawl’s scrape, the result (text/markdown of the page) will be quite large. We can show a snippet (first few lines) in the panel with a “View more” that expands, or open an overlay with scrollable content. We should also provide a “Copy to Clipboard” button for convenience, so the user can easily paste it into ChatGPT’s input.
- If the result is very structured (like the output of a reasoning tool might be a list), we could format it nicely (perhaps using &lt;pre&gt; for preserving JSON or bullet points for lists).
- The key point is to move beyond the placeholder and make the extension a genuine viewer for tool outputs. This may require some design work for the UI to accommodate results without overwhelming the space. A method is to use the existing Dev tab or repurpose it as a “Output” tab that shows the last result from any tool call, along with context (which server/tool it came from). Alternatively, within the Tools tab, each tool invocation could append its result below the input field. We will decide on UI specifics during implementation, but the capability must be there.
- **Server Management Features:** Improve how users manage MCP servers in the extension:
- The current UI lists some hard-coded servers with enable/disable toggles and “Set default”[\[40\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=%7D%29%3B%20const%20toggle%20%3D%20document.createElement%28,checked)[\[41\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=toggle.appendChild%28document.createTextNode%28). We should allow the user to**add and remove servers** via the Settings tab, instead of only having the pre-seeded list. In the redesign, include a simple form in Settings: the user can input a server name, type (WebSocket URL or preset like “firecrawl”), and connection info (URL or instructions). This gets saved to chrome.storage and reflected in the Servers list. This way, if they want to integrate a new MCP server (for example, one not pre-listed, like an “Everything” server or a custom one), they can do so without editing code.
- **Default Server Concept:** Maintain the idea of a default server (for convenience, e.g., the default could be a general-purpose server like “Local Dev” or perhaps a user’s chosen primary). The default might be used for quick-access tools or if we later add a feature like “send selected text to default server’s tool.” The UI should clearly mark which is default (currently done with a badge[\[42\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=if%20%28state.defaultServerId%20%3D%3D%3D%20srv.id%29%20,header.appendChild%28badge%29%3B)) and allow changing it easily (one-click “Set default”). This is working now, but we will ensure it’s robust.
- **Per-Server Status Indicators:** Keep and refine the status dot that shows if the last interaction was OK or had an error[\[43\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=header.className%20%3D%20%22mcp,name%22%3B%20name.textContent%20%3D%20srv.name)[\[44\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=dot.className%20%3D%20%22mcp,bad). We can extend this to maybe indicate active connection vs disconnected (for WebSocket ones). For example, a green dot for “connected and last call OK”, red for “last call failed”, grey for “disabled,” etc. The background already stores statuses for echo calls[\[45\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L346-L355), so we can build on that for other tools. A small but useful addition might be a “Reconnect” button if a connection is lost.
- **Integration with ChatGPT Input:** To truly “bridge” MCP and ChatGPT, implement a convenient way to move data between the extension and the chat interface:
- **One-click Insert to Prompt:** As mentioned, a button to insert text (like a fetched web article or a memory recall) into the ChatGPT textarea. Technically, the content script can find the &lt;div id="prompt-textarea"&gt; (the ProseMirror editable field[\[46\]](file://file-3ZPr3e7BhXfnwbhJc458qs#:~:text=expanded%2Fcomposer%3Apx,hidden%22%3E%3C%2Fp%3E%3C%2Fdiv%3E%3C%2Fdiv%3E%3C%2Fdiv%3E%3Cdiv)) and inject text into it. We must do this carefully (possibly by triggering the same events as a user paste to not break any internal state). We can also target the hidden &lt;textarea name="prompt-textarea"&gt; for simplicity by setting its value and dispatching an input event if needed. This feature means after you fetch some info via the extension, you can click “Send to Chat” and the text will appear in the compose box – the user then hits Enter to send (allowing them to edit if needed before sending). This saves copy-paste steps and makes the workflow smoother.
- **Context Menu Integration:** Consider adding a browser context menu item (via the contextMenus API) for text selection on any page (or specifically on ChatGPT). For example, the user could highlight text in ChatGPT’s conversation (or elsewhere in Chrome), right-click and see an option like “Send to \[Default MCP\]” or “Analyze with \[Tool\]”. This would then invoke a tool with that text as input. A concrete use-case: highlight code in the chat and choose “Run code analysis” if an MCP server provides such a tool. Implementing this would involve registering context menu items in the background (requires adding the "contextMenus" permission). While not a priority for the first reboot (since the focus is ChatGPT page itself), this is a method to extend usability outside the sidebar’s UI. It can be planned now (with maybe a basic example like “Echo selected text” to default server) and expanded later.
- **Improved Logs/Dev Panel:** The Dev tab currently shows raw logs and worker info【5†】. This is useful for development but can be made more user-friendly:
- Keep the rolling logs (helpful for debugging tool calls or connection issues) but perhaps categorize or highlight errors vs info (color code entries). The background logging via appendLog is already there[\[47\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L186-L194); we can improve the display by, say, showing \[error\] lines in red.
- Show connection status details: e.g., when connected to a WebSocket MCP, display “Connected to X (Y tools available)” – this feedback already happens as a toast and log[\[17\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L380-L388)[\[48\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=srv.url%20,res.tools%7C%7C%5B%5D%29.length%7D%20tools), but could be in the UI persistently.
- The Dev tab might remain mostly for the developer (Jason) and not for end-users, so it’s fine to include verbose info. We just ensure it doesn’t clutter the main user experience (maybe hide behind a toggle or only show if a certain flag is set).
- **Performance and Stability Features:** While not user-facing, it’s worth mentioning:
- Ensure the extension does not slow down ChatGPT noticeably. The MutationObserver and reapply logic should be throttled or debounced if needed, to avoid performance hits during large DOM changes (like when ChatGPT streams a long answer, that triggers many mutations). If performance is an issue, one method is to observe specific nodes and disconnect observer when not needed.
- Memory usage: clean up any stale connections. For example, if a WebSocket server was connected and then user disables it, consider closing that socket to free resources. Also enforce a reasonable limit on log size (the code currently keeps last 500 logs[\[49\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L92-L99), which is good).
- Error handling: every asynchronous call (storage, fetch, websocket RPC) should catch errors and not crash the background. The background script should be resilient (since in MV3 a runtime error can terminate the service worker). We will add try/catch around critical sections and use sendResponse with error messages rather than letting exceptions propagate unhandled[\[50\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L412-L420). This makes the extension more stable during edge cases.

**Prioritization:** Initially, the must-have features are connecting to an MCP server that provides clear utility (web content fetching via Firecrawl or similar) and displaying tool results in the UI. These directly turn the extension from a demo into a functional assistant. Secondary features like memory integration, context menus, or advanced planning tools can follow once the core pipeline (UI ↔ background ↔ MCP server) is solid and proven with one or two use cases.

By focusing on these core improvements, the extension’s **value proposition** becomes clear: it will let the user do things _ChatGPT alone cannot do_, using the MCP tool ecosystem – whether that’s browsing the web, retrieving long-term knowledge, or performing complex reasoning – all within the comfort of the ChatGPT webpage.

## 4\. Audit of Existing Code & What to Scrap or Revise

Before rebuilding, it’s important to assess the current codebase (from the GitHub repo and provided files) to identify what can be salvaged and what should be discarded or refactored. The previous implementation got some things right (UI isolation, basic messaging), but also has areas that need rebooting:

**What’s Worth Keeping:**

- **Shadow DOM UI Approach:** The existing extension injects a &lt;div id="mcp-shadow-host"&gt; (for example) and attaches a shadow root with all UI elements styled under prefixed classes .mcp-\*[\[1\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md#L16-L24). This is a sound approach to avoid CSS conflicts with ChatGPT. We will keep this concept. The CSS token variables (like --mcp-accent, --mcp-border, etc.) defined for theming[\[51\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md#L18-L26) are also useful for consistent styling; we can carry those into the new UI, possibly expanding the theme or making it easily adjustable.
- **Floating Toggle + Sidebar UI Pattern:** The “small MCP entry control” (the little tab or chip) that toggles a sidebar panel was a good UX choice – it minimizes footprint and is discoverable when needed[\[52\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md#L10-L18). The panel with tabs (Servers, Tools, Dev, Settings) provides a structure for features. We will keep a similar UI/UX unless strong reasons arise to change. (We’ll just ensure the panel is more stable in positioning and that it could alternatively dock as a true Chrome sidebar in future if needed.)
- **Basic Message Schema and Handler:** The code uses one-shot chrome.runtime.sendMessage with a requestId to correlate responses[\[53\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L2-L11)[\[54\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L407-L415). The background listener uses sendResponse inside an async function to handle promises correctly[\[54\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L407-L415) – this is correct usage for MV3. This architecture will be kept. The list of message kinds implemented (GET_SETTINGS, LIST_SERVERS, CONNECT_MCP, CALL_MCP_TOOL, etc.) covers most needs already[\[53\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L2-L11)[\[55\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L18-L21). We will extend or adjust it, not throw it away entirely. For instance, we might add “ADD_SERVER” or “REMOVE_SERVER” messages for the new settings UI, but the pattern remains.
- **chrome.storage usage:** Using chrome.storage.sync for persistent settings and chrome.storage.local for ephemeral data (status, logs) is appropriate[\[11\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L42-L50)[\[12\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L70-L78). We will maintain this, possibly modularizing access. The first-run seeding logic (seeding default servers on install) is also worth keeping (with updated list of servers)[\[56\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L156-L164). We’ll ensure to update the seed list to include any new recommended servers (e.g., Firecrawl) and maybe drop those that don’t make sense to pre-load. The migration logic placeholder (ensureSettings checking version, etc.) is fine to keep for forwards compatibility[\[56\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L156-L164)[\[57\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L166-L175).
- **Local Echo Server Mechanism:** The quick echo test (trying an HTTP GET to localhost:8787 and falling back to local echo) is a clever way to let users verify connectivity without requiring any external setup[\[58\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L311-L320)[\[59\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L324-L328). We can keep this as a diagnostic feature (“Echo” button) on the default Local Dev server entry. It’s harmless and helps validate that messages are working. We might not emphasize it in UI, but it’s good for development and can remain as a simple tool.
- **Logging System:** The background’s simple logging to local storage (with timestamps and levels)[\[47\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L186-L194)[\[60\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L361-L369) and the Dev tab displaying those is quite useful for debugging. We should keep and perhaps expand it (maybe include which component logged the message). This helps during development and even for advanced users to see what’s happening under the hood. It doesn’t impact normal use unless the user opens Dev tab.

**What to Scrap or Heavily Refactor:**

- **Hardcoded and Unused Server Entries:** The current createMockServers() seeds several mcp://... entries (Firecrawl, Puppeteer, etc.) that are not actually functional[\[61\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L112-L120)[\[62\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L121-L129). These use a pseudo-URL scheme “mcp://name” with the intention that maybe the extension or environment would resolve it. In practice, the code never implements resolution for “mcp://” schemes – any non-ws:// server is just treated as an echo target in content script[\[34\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=btnConnect,res.tools%7C%7C%5B%5D%29.length%7D%20tools)[\[35\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=try%20,OK%27%20%3A%20%27%21%27%2C%20color%3A%20isOk). This is confusing and misleading to users (seeing entries that do nothing). We should remove or replace these placeholders. In the new plan, we will either:
- Update these entries to real connection info (e.g., Firecrawl could be set to an actual WebSocket URL if the user runs it locally or a wss URL for their cloud service; Puppeteer could be pointed to an available server if one exists, or omitted).
- Or initially, reduce the seed list to just one or two fully working examples (Local Dev and maybe a disabled slot to be configured by user). We don’t want a clutter of non-working items. We can provide templates in documentation rather than preloading everything. In summary, scrap the pseudo URL approach unless a resolution mechanism is added. A cleaner approach: use a field like type: "builtin" or requiresExternal:true to mark servers that need separate setup, and hide them unless configured.
- **Monolithic Content Script Structure:** The content script currently mixes DOM selection, element creation, event binding, state refresh, and rendering all in one big function/file[\[63\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=function%20render%28servers%2C%20state%2C%20statuses%29%20,item%22%3B%20li.dataset.id%20%3D%20srv.id)[\[40\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=%7D%29%3B%20const%20toggle%20%3D%20document.createElement%28,checked). It will be practically rewritten in the modular form as described. This is less about throwing away functionality and more about re-architecting it. For instance, functions like findComposerContainer()[\[64\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=function%20findComposerContainer%28%29%20,form) and the MutationObserver setup[\[25\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=const%20mo%20%3D%20new%20MutationObserver,window.addEventListener%28%27resize%27%2C%20reapply%29%3B) can be kept conceptually but re-coded in a cleaner way within a module. The**scrap** here is the inline creation of every HTML element manually and repetitive code for each tab. We might introduce a lightweight templating or use lit-html / Preact, etc., or at least systematically construct UI elements. The outcome should be the same UI, but code that’s easier to adjust. We’ll also remove any dead code paths (the conversation logs suggest there were multiple attempts, e.g., createPanel vs createSidebar functions, some of which might be remnants[\[65\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=match%20at%20L3187%20const%20shadow,refresh%28%29%3B)[\[66\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=const%20shadow%20%3D%20createShadowHost,refresh%28%29%3B)).
- **Incomplete Tool Handling:** The current implementation of showing tools after connecting to a server is rudimentary. It renders a list of tool names with an input box and Run button[\[67\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=function%20renderToolsUI%28container%2C%20id%2C%20tools%29%20,list%27%3B%20tools.forEach%28%28tool%29%20%3D%3E)[\[68\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=const%20run%20%3D%20document,showToast%28shadow%2C%20%27Tool%20OK), but as noted, it doesn’t display results. We will revamp this in the UI code. The code around renderToolsUI and how it attaches a .mcp-tools-panel under a server list item is a bit clunky[\[69\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=%2F%2F%20render%20tools%20UI%20just,else) – likely to be replaced with a dedicated Tools tab UI. So effectively, scrap the approach of injecting the tools UI in multiple places (under each server list item) and instead have a single coherent view for tools. The new approach might be: when a server is connected, its tools populate the Tools tab (or an expandable section). Simplifying this will avoid issues where multiple servers have tool sub-panels open and possibly overlapping or complicating state.
- **Message Handling Gaps:** Some message types were stubs or not thoroughly used. For example, LIST_MCP_TOOLS exists but the content script doesn’t call it (since it instead got tools via the CONNECT response)[\[55\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L18-L21)[\[70\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L388-L396). We might remove unused messages to reduce complexity. Another example: CALL_MCP_TOOL returns a result (possibly including content), but the content script currently just logs or toasts it without using the data[\[71\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=const%20parsed%20%3D%20args,showToast%28shadow%2C%20%27Tool%20failed). We will refactor that flow so that the result is passed back properly and utilized. Any unused branches in background message handling (like error cases that just log) we will handle more systematically (maybe propagate an error toast).
- **Lack of Streaming/Port:** The one-shot messaging is fine for now, but if we foresee streaming output (some MCP servers send incremental results), the current design doesn’t support it (and decisions log noted this as a limitation[\[72\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DECISIONS.md#L8-L13)). We won’t implement streaming in this reboot unless needed, but we should scrap the assumption that it will never be needed. That means designing our code such that moving to a long-lived connection (using chrome.runtime.connect and ports) is possible without a full rewrite. For now, one-shot is simpler – but scrap any code that might incorrectly try to handle streaming (I don’t think current code did, it just doesn’t attempt streaming at all). Essentially, keep in mind where changes would be needed for streaming (like not making UI assume a single response per request).
- **UI Polishing and Consistency:** Minor things to fix: for instance, the Connect button text changes to "Echo" for non-WS servers[\[73\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=actions.className%20%3D%20%22mcp,url). If we remove the fake servers, we might not need this conditional labeling – or we repurpose it (maybe "Connect" vs "Run" if server is offline?). We will simplify the UI labels to avoid confusion. Also, the toggle “Enabled” state was in place to allow filtering out servers without deleting them[\[40\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=%7D%29%3B%20const%20toggle%20%3D%20document.createElement%28,checked). This is a nice feature, but if not critical we can scrap or delay it until we have many servers to manage. Possibly keep it if easy, but it's lower priority than core function.
- **Dev Frustration Artifacts:** The chat log suggests some workarounds and confusion that might have left their mark in code (e.g., focus issues, multiple windows). For example, earlier conversation indicates the developer accidentally opened ChatGPT in a separate profile where extension wasn’t logged in[\[32\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=Of%20course%2C%20apologies%20for%20the,with%20logins%20and%20extension%20loading). There might not be specific code reflecting that, but ensure no leftover console.logs or debugging flags remain. The repo might contain commented-out blocks from debugging (we should remove those to clean up). We should also double-check that the manifest host_permissions cover all needed domains (it has chat.openai.com and chatgpt.com which is fine[\[74\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/manifest.json#L12-L17)), and scrap any that aren’t needed (both domains might not be necessary if one redirects to the other, but keeping both doesn’t hurt).
- **Build/Tooling Artifacts:** The current project is vanilla JS with no build process (they even considered moving to TS in iteration B[\[75\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DECISIONS.md#L29-L33)). There might be leftover configs (like the .vscode/launch.json and some npm bits) that we’ll replace with a new toolchain. We scrap the idea of continuing without a bundler for iteration B – moving to a proper build setup is recommended now for maintainability. So any hacks done to avoid a build (like using JSDoc for types) can be replaced with actual types in TS.

In summary, **we keep the foundational pieces but refactor heavily for clarity**. The UI and background logic will be essentially rewritten in structure (if not entirely in functionality), so that going forward it’s easier to add features without breaking things. The new code will also eliminate any half-implemented features – every visible element in the UI will correspond to something that truly works or is clearly marked as coming soon.

We’ll also take this chance to **improve naming and documentation** in the code. E.g., function names like refresh() in content script did multiple things (fetching servers and statuses)[\[76\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=). In the new code, we might have loadServerList() and updateStatuses() separately for clarity. Small changes like that contribute to long-term health of the project by making the code self-explanatory.

## 5\. Open-Source MCP Servers & Integration Strategy

One of the extension’s goals is to leverage the growing ecosystem of MCP servers[\[77\]](https://github.com/modelcontextprotocol/servers#:~:text=The%20servers%20in%20this%20repository,implemented%20with%20an%20MCP%20SDK) to empower the user with various tools. Here we identify the best open-source MCP servers for our core use cases, and outline how to integrate them, including any security/licensing considerations:

**Key MCP Servers to Use:**

- **Firecrawl (Web Scraping & Browsing):**_Use case:_ Enable ChatGPT users to fetch web content and perform searches. Firecrawl’s MCP server is specifically designed for web scraping, crawling and content extraction[\[37\]](https://docs.firecrawl.dev/mcp-server#:~:text=Features). It’s open-source (MIT license) and can be run locally or used via a cloud endpoint with an API key[\[78\]](https://docs.firecrawl.dev/mcp-server#:~:text=You%20can%20either%20use%20our,keys)[\[79\]](https://docs.firecrawl.dev/mcp-server#:~:text=Copy).**Integration:** We will allow configuring the Firecrawl server in the extension. The user can either input the remote URL (with their API key) or run it locally via npx firecrawl-mcp and point the extension to ws://localhost:... as provided by Firecrawl docs. In the extension UI, Firecrawl can appear as a server entry (pre-seeded but disabled until configured). Once connected, its tools (e.g. firecrawl_scrape, firecrawl_search) show up in the Tools tab. The user can then use a simple form to provide a URL or search query and run them. We should design dedicated UI prompts for these common tasks for ease of use (for example, in the Tools tab, if Firecrawl is the default server, show a field “URL to scrape” or “Search query”).**Security:** Using Firecrawl means potentially fetching arbitrary URLs. We must warn users that they should avoid fetching sensitive pages that require auth, etc., unless they trust the environment. Firecrawl itself imposes rate limits and requires an API key for heavy usage[\[78\]](https://docs.firecrawl.dev/mcp-server#:~:text=You%20can%20either%20use%20our,keys). For local use, running it with an API key still (to use their service) means trusting that server. This is fine for personal use, but if distributing extension, clarify that it’s optional and the user’s responsibility to get a key. License-wise, MIT means we can integrate it freely. If the user doesn’t provide a key or run it, the server just stays disabled – the extension should handle that gracefully (maybe with a note “Firecrawl requires setup”).
- **Sequential Thinking (Reasoning Assistant):**_Use case:_ Helping break down complex tasks or generate step-by-step plans[\[38\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20Memory%20,Time%20and%20timezone%20conversion%20capabilities). License is likely MIT (as it’s in the reference server repo).**Integration:** The extension can include Sequential Thinking as an optional server (perhaps not enabled by default, but available to add). If the user connects it (they might need to run a local instance via npx @modelcontextprotocol/server-sequential if such exists, or perhaps connect to a community provided endpoint), it would provide tools that we can expose. E.g. a tool named “think_steps” that expects a problem description and returns a plan. We integrate it similar to how Local Dev is integrated – via WebSocket JSON-RPC.**UI:** Possibly a custom UI element (a text area for input problem) in the Tools tab when this server is selected, because the output might be multiline (like a numbered list of steps). We could enhance the display for that (like formatting each step).
- **Memory (Knowledge Graph Memory):**_Use case:_ Persistent memory across sessions[\[80\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20Filesystem%20%20,solving%20through%20thought%20sequences)[\[38\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20Memory%20,Time%20and%20timezone%20conversion%20capabilities). License MIT.**Integration:** If the user runs npx @modelcontextprotocol/server-memory (as indicated in the repository[\[81\]](https://github.com/modelcontextprotocol/servers#:~:text=For%20example%2C%20this%20will%20start,the%20Memory%20server)), they get a local memory server. We can support connecting to it. Tools might include memory/save and memory/query.**UI:** We integrate this by adding UI controls to save highlighted text to memory (maybe a button in the extension UI “Save last answer to Memory”) and a small search bar in the Tools tab for querying memory. Implementing this fully might be phase 2, but we design the system such that adding it is straightforward. We will ensure the extension can handle multiline inputs/outputs for such use.**Security:** The memory server is local and stores data on the user’s machine (or cloud if they set one up), so privacy is in user’s control. No licensing issues for usage. We just need to ensure the user understands that saving data via the extension means it’s stored in the memory server (which might be plain files or a database).
- **Fetch (Web Content Fetching & Conversion):** This is another reference server focusing on retrieving web pages and possibly summarizing or converting them[\[82\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20Fetch%20,based%20persistent%20memory%20system). It overlaps with Firecrawl’s purpose, but could be simpler (maybe it just fetches HTML or text). Depending on ease of use, we might consider it if Firecrawl is too heavy for some users.**Integration:** Similar to Firecrawl – user provides a URL, gets content. Possibly the advantage of Fetch is it might not require an API key if run locally. We could give the user a choice or support both. But to avoid redundancy, we may focus on Firecrawl (since it’s quite comprehensive with search and crawl features).
- **Puppeteer or Playwright (Browser Automation):**_Use case:_ More advanced or interactive web automation, like clicking through a page or snapshotting dynamic content. The original plan included a Puppeteer MCP server[\[83\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=match%20at%20L887%20,MCP%2C%20Sequential%20Thinking%2C%20Streamable%2C%20Memory), but it was archived in the reference repo[\[84\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20Google%20Maps%20%20,interaction%20and%20business%20intelligence%20capabilities). There is mention of a Playwright server which is likely a modern alternative[\[85\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20BrowserLoop%20,capture%20with%20configurable%20formats%2C%20viewport).**Integration:** This is lower priority for now, as it’s more complex. However, we keep it in mind: if the user needs to do something like “log into a site and fetch data behind auth” or handle pages with heavy JS, a browser automation server could do that (running a headless browser and executing instructions). For the extension, we would treat it like any other server – user runs it locally (Puppeteer typically can’t be easily hosted due to needing a browser) and connect via WebSocket. If integrated, we might add specialized tool UIs, e.g., a “Screenshot URL” tool or “Extract selector” tool. Given complexity, we might leave this for future development, but ensure our architecture (especially message handling) can accommodate potentially larger payloads (like images if a screenshot is returned – though images via JSON RPC would likely be base64 strings which could be huge; perhaps not feasible to do directly). We note that heavy binary data might not be ideal through MCP+extension, so maybe skip images. Focus on textual data extraction.**Security:** Running a Puppeteer/Playwright server means a headless browser on user’s machine – that has the same security considerations as any browser automation (it can do anything a user can). Since it’s local, it’s fine; just ensure user is aware of what it’s doing. License should be fine (likely MIT or Apache on those SDKs).
- **Other Noteworthy Servers:** Depending on the user’s interests, there are many others: e.g.,_Filesystem_ (to read local files securely)[\[82\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20Fetch%20,based%20persistent%20memory%20system),_Git_ (to allow ChatGPT to access a code repository via MCP)[\[82\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20Fetch%20,based%20persistent%20memory%20system), or even third-party ones like_OpenAI/Anthropic official integrations_. For now, we prioritize the ones above, but our design in section 1 ensures adding these later is easy. For example, if the user wants to incorporate the Filesystem server to let ChatGPT see local project files, we’d add a server entry for it, and possibly a UI in the extension to choose a file or directory to expose. We should confirm licenses (the reference ones are generally MIT). For third-party (like some SaaS integrations listed in the MCP servers repo), those might have their own licenses or require API keys – we won’t include those by default, but the user could add them manually via the Settings if they wish.

**Integration Strategy – UI & Routing:**

- The extension’s**Servers tab** will list all configured servers. Each server can have metadata (name, description, tags as in current storage schema[\[86\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L26-L34)). We might include an icon or color coding for types (not required, but visual cues help). The user can enable/disable them (disabling means the extension won’t allow calls to it, effectively ignoring it without removal). For integration, enabling a server like Firecrawl would require user to have it accessible – maybe we check connectivity when enabling and show status (e.g., if Firecrawl endpoint is not reachable, show a red dot).
- The**Tools tab** (or section) will dynamically show tools for the selected or default server. If Firecrawl is default and connected, Tools tab could show: “Scrape (inputs: URL), Search (inputs: query), etc.” If the user switches default to another, update the list. If we allow multiple at once, perhaps the Tools tab can have a dropdown to select which server’s tools to use. Simpler to start with one-at-a-time via default.
- For each**tool invocation**, the background needs to route the call to the correct server’s connection. Our message will contain { id: serverId, name: toolName, args: {...} }[\[55\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L18-L21), so the background can look up which connection (via the id) to use. This is already in place with mcpConnections map in current code[\[87\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L194-L203). We will keep that mechanism: e.g., calling Firecrawl’s “scrape” tool will use the WebSocket connection stored under mcpConnections\['firecrawl'\] to send a JSON-RPC request. The background’s CONNECT_MCP handler will need to know how to launch connection for “mcp://firecrawl” if we keep that scheme – more straightforward is to require a ws/wss URL. Possibly we will allow url: "ws://.../firecrawl" directly in config so no special-case code. Another idea: have the extension recognize certain scheme or alias and replace it with a standard URL (like if url field is “mcp://firecrawl”, we internally map to wss://mcp.firecrawl.dev/&lt;apiKey&gt;/sse as per Firecrawl docs[\[88\]](https://docs.firecrawl.dev/mcp-server#:~:text=Ask%20AI) when connecting). This could be convenient but requires storing the API key. We might implement a prompt in Settings when adding Firecrawl server to input the key and then form the proper URL.
- **Security Considerations:** Since the extension runs code in the browser context and communicates with outside servers (even if local), we must ensure we don’t create attack vectors:
- Only connect to endpoints the user has configured. There’s no auto-connecting to unknown URLs. The user explicitly enables a server and potentially enters its URL/credentials. This prevents, say, a malicious webpage from somehow triggering our extension to connect to an unintended server (not that it easily could, but we sandbox anyway).
- The extension should sanitize any data returned by tools before injecting into the DOM. For text content it’s usually fine, but if a tool returned HTML or JavaScript (not typical, as MCP usually returns data, not raw HTML unless the server explicitly does), we should not render it as active HTML in our extension panel without escaping. We’ll treat all tool output as untrusted text and display accordingly (e.g., using textContent or equivalent).
- We won’t directly expose any user secrets to the servers. E.g., if ChatGPT page has some tokens in DOM, our extension should not accidentally pass those to an MCP server. The only data that goes to MCP is what the user inputs or what we intentionally gather (like selected text).
- **Licensing:** All recommended servers are open-source (MIT or similar) – since the extension is currently for personal use, we can use any of them freely. If eventually releasing publicly, MIT is compatible with most usage. We should avoid integrating any code or server that has a restrictive license (none of those listed appear to be viral licenses, mostly MIT/Apache). Firecrawl’s client usage might involve agreeing to terms if using their cloud service; since we treat it as user-supplied configuration, that’s on the user’s side, not baked into our code.
- We should include a notice in README or extension docs that “This extension allows integration with third-party MCP servers. It’s the user’s responsibility to comply with those servers’ terms (e.g., API keys usage) and to secure any sensitive data.”

**Plugging into Chrome Features (tabs, overlays):**

The question mentions “via tabs, context menus, overlays” – how to plug in these servers: - We already covered context menus (one way to send data to servers). - Overlays: For example, Firecrawl might return a lot of data. We could open an overlay window or a new browser tab for viewing large results (like an entire crawled page). A neat idea: if a tool returns HTML or some media, the extension could create a new temporary tab to show it. But that might be overkill and outside our main use-case (we mainly need text for ChatGPT). However, implementing something like “Open result in new tab” for certain outputs (with proper blob URLs) could be a feature down the line. - Using Chrome’s new Side Panel API: Chrome has an API to show extension content in a side panel (like how Reading List or Google Lens results appear). If that becomes stable, our extension could register to use it. That might integrate better than our injected sidebar. But that’s a significant change and not supported in all contexts yet. We note it as future exploration: it could solve some anchoring issues by having a persistent browser UI, but also might not overlay exactly within ChatGPT’s page. For now, we stick to in-page panel for broad compatibility. - Using Chrome tabs in general: If a server required OAuth login (some integrations do, like if one integrated a Gmail MCP server, it might require user to log in), we might need to open a tab or window for that auth. We’re not doing such servers now, but it’s something to keep in mind. Our extension should be ready to handle e.g. chrome.identity flows or launching confirm pages if needed for future integrations.

In essence, we incorporate open-source MCP servers that align with common needs (web browsing, memory, reasoning, automation), providing configuration in the extension for each. We ensure the integration is secure and user-controlled. The extension acts as a flexible container: the user can plug in different MCP endpoints (open-source or their own) without code changes, and the UI will adjust to present the available tools. This **future-proofs** the extension – as new MCP servers emerge, the user (or we) can add them to the list. The architecture already supports multiple servers; we’re extending that with usability in mind.

## 6\. Developer Toolchain & Workflow Practices

To efficiently develop and maintain this project, a modern toolchain and disciplined practices are needed. Here are recommendations for the development environment, testing, and workflows, including how Jason can iterate quickly with Cursor:

- **Use a Build System (TypeScript + Bundler):** It’s time to move to TypeScript for type safety and better structure (as noted as a likely step for iteration B)[\[75\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DECISIONS.md#L29-L33). Adopting a bundler will allow us to use modules and maybe frameworks. One great option is**WXT (Web eXtension Toolkit)**, a next-gen framework for extensions that supports MV3, TypeScript, and has hot-reload in dev[\[89\]](https://github.com/wxt-dev/wxt#:~:text=wxt,imports%20%C2%B7). WXT can auto-reload the extension on code changes and even open a browser with the extension loaded for rapid testing[\[90\]](https://www.reddit.com/r/chrome_extensions/comments/1fs9om2/i_wrote_wxt_a_relatively_new_framework_for/#:~:text=I%20wrote%20WXT%2C%20a%20relatively,that%20automatically%20opens%20the%20browser)[\[91\]](https://github.com/wxt-dev/wxt#:~:text=Features%20%C2%B7%20Supports%20all%20browsers,imports%20%C2%B7). This dramatically speeds up development: you can code, save, and see the extension reload in Chrome almost immediately. Alternatively, a custom setup with Vite or Webpack is possible, but WXT seems tailored for exactly this scenario, with minimal config needed[\[89\]](https://github.com/wxt-dev/wxt#:~:text=wxt,imports%20%C2%B7). Jason should consider initializing the project with WXT (there is likely a template to follow).
- **Hot Reload:** When developing the content script UI, hot-reload (HMR) is very useful – you can tweak the UI and see changes without a full extension reload. WXT advertises HMR support in dev mode[\[89\]](https://github.com/wxt-dev/wxt#:~:text=wxt,imports%20%C2%B7). This will significantly reduce friction that was faced earlier (like repeatedly packaging or manually reloading extension which can be slow).
- **Source Maps & Debugging:** Ensure the bundler generates source maps so that debugging in Chrome DevTools shows original TS code. This will help when stepping through logic or catching errors.
- **Development Environment Setup:** Keep using**Cursor** (or similar IDE) but pair it with Chrome’s extension debugger. For instance, open chrome://extensions, enable developer mode, and inspect the background service worker and content script console. This way, when Cursor’s AI writes some code, you can immediately run the extension and see logs or errors in the console to verify. A good practice is to frequently load the extension and ensure no runtime errors – since MV3 service workers can quietly stop if an error is thrown, checking the console logs is key.
- **Testing Strategies:**
- **Manual Testing:** Because this is a UI-centric extension, manual testing on the ChatGPT site is crucial. After each major change, run through a short test plan: Does the MCP button appear? Does the panel open/close correctly? Can you connect to the local dev server and get a response? Does Firecrawl fetch a page as expected? etc. Document such scenarios so they can be quickly tested after each iteration to catch regressions.
- **Automated Testing (Puppeteer):** We can use Puppeteer (the Node library, not the MCP server) or Playwright in a test script to automate some behaviors of Chrome with the extension. For example, write a small Node test that:
  - Launches Chrome with the extension loaded (Chromium can be launched in headless mode with an extension).
  - Navigates to a test page (perhaps a local dummy page or ChatGPT if login can be handled).
  - Checks that the extension injected elements are present in the DOM.
  - Simulates clicking the MCP toggle and verifies the sidebar appears.
  - Simulates clicking a Connect button and waits for a response element or log.
  - This kind of integration test can be part of the repo (maybe triggered manually because it might require credentials if testing on real ChatGPT). While not trivial, having at least one automated test for “injection works and echo returns OK” would ensure the core flow doesn’t break during refactoring.
- **MCP Server Stubs for Testing:** To test the extension without relying on external servers, we could implement a dummy MCP server in Node (similar to the provided localdev echo server[\[36\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/scripts/mcp-localdev.js#L18-L26)). Actually, the mcp-localdev.js already serves as a dummy MCP server with echo, time, sum[\[36\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/scripts/mcp-localdev.js#L18-L26). We can use that in tests – run it, then have the extension connect to it, and verify the Tools list populates with "echo", "time", etc., and that running them yields expected output. This ensures our connection and RPC logic is solid.
- **Linting and Formatting:** Adopt ESLint/Prettier or the equivalent for consistent code style, especially since using AI can sometimes introduce small style differences. Having an auto-format on save (with Prettier) will keep the code clean. Also, enable TypeScript strict checks to catch undefined errors or type mismatches early – this can prevent certain classes of bugs that were easy to slip in vanilla JS.
- **Development Workflow with Cursor (AI):**
- **Small Prompt Chunks:** Rather than asking the AI for the entire extension code, break tasks as in the initial plan (Iteration A had steps 0–7[\[92\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=Planning%20tasks%20for%20Iteration%20A,brief%20%2B%20constraints)[\[93\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=3)). For iteration B, define tasks like “Implement storage module”, “Implement content script mount and toggle”, “Implement connect and call flows”, etc. Work on them one by one. This makes it easier to pinpoint issues. Also, it’s easier to review smaller patches for correctness.
- **Incorporate MCP Tools in Dev:** Interestingly, we can use the MCP servers to aid development itself. For example,**Firecrawl** can be used to scrape the ChatGPT page for changes in structure if something breaks our selectors.**Puppeteer MCP** can be used to programmatically test selectors or simulate events while still in the Cursor environment. The earlier development log shows tasks where these were used to generate reports on DOM structure[\[94\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=1). Continue this practice: if uncertain about a new element’s selector, use the Puppeteer MCP through Cursor to inspect. If we want to ensure our MutationObserver picks up the right changes, we could use the sequential reasoning tool to think through possible DOM change scenarios. This synergy (“use MCP to build MCP”) should be leveraged whenever it can save time or improve reliability.
- **Memory for Project Facts:** Use the Memory server (or Cursor’s built-in vector memory if available) to store key details (like the message schema, or the meaning of each server) so the AI doesn’t forget them in later prompts. This avoids re-explaining from scratch. For instance, you might store this entire design plan in a memory slot, so later the AI can query “what were the design rules?” and retrieve them. Cursor likely has features to utilize the memory MCP which we should exploit to keep context.
- **Continuous Documentation:** Maintain the design.md and decisions.md in the repo with updates from this plan[\[95\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L42-L44). After each major decision or change, log it. This not only helps human collaborators but also you can feed those files to the AI to remind it of what’s been agreed. A disciplined habit is: when you find yourself asking “why did we do X?”, check decisions.md; if it’s not there, add it so future you doesn’t have to puzzle it out. This prevents the AI from undoing a previous deliberate choice because it wasn’t aware of the rationale.
- **Puppeteer/Firecrawl for QA:** After making changes, one can use Firecrawl to snapshot the ChatGPT page with the extension active (maybe running in a local browser) to see if the MCP elements are correctly placed in various conditions (e.g., different window sizes, dark vs light theme). If something looks off, we catch it early. If we integrate such QA in a script, it’s even better.
- **Version Control Practices:** Use Git branches for major features/refactors. This way, if the AI-generated changes inadvertently break something major, it’s easier to revert or compare. Frequent commits with descriptive messages (even if AI generates code, you write the commit message summarizing changes) will create a history that is easier to navigate when debugging regressions.
- **Efficiency Tips for Jason:** Since Jason is the user, a few tips:
- Stay in the**feedback loop**: whenever the AI produces code, test it immediately. Don’t let a lot of code accumulate without running, because debugging many changes at once is hard. The earlier frustrations likely came from trying to do too much at once and then dealing with compounded issues.
- Use**Cursor’s diff review**: before accepting an AI code change, review the diff. This helps catch obvious mistakes (like it misunderstanding an API or forgetting an await).
- If the AI seems to hallucinate about some API or behavior, ground it by providing actual documentation (Chrome extension docs, MCP specs, etc.) in the prompt.
- Keep the tone with the AI**firm and clear** about requirements – e.g., “Do not introduce any new global variables” or “All functions must handle promise rejections”. Being explicit in instructions will yield better adherence.

By setting up a powerful dev environment (with hot reload, tests, and AI assistance) and following these workflows, development will be more enjoyable and productive. The combination of modern toolchain + MCP tools for dev + AI guidance is potent – we just have to channel it properly. This addresses the previous pain points (like manual reloads, environment confusion, or AI going off-track) by ensuring rapid feedback and maintaining context.

## 7\. Prompt Handoff for Next Iteration

Finally, to smoothly continue development with a fresh model (e.g. using Cursor’s GPT-5-high or similar), we prepare a comprehensive prompt that can be given to the AI. This prompt will summarize the current project state, goals, decisions, and next tasks, with clear structure and tone instructions to avoid past mistakes. The aim is to “handoff” this plan so the AI can start implementing the redesign according to our blueprint.

**Draft Handoff Prompt:**

**Project:** MCP Web Bridge Extension – **Iteration B (Reboot)**
**Current Version:** A partial MV3 Chrome extension that injects an MCP control panel into ChatGPT. Solid UI, but limited functionality.
**Goal of Iteration B:** Re-architect and implement a production-grade core with real MCP tool integration for ChatGPT.com. Focus on modularity, reliability, and meaningful features (web browsing via MCP, etc.).

**Key Components & Design:**

- **Content Script (ChatGPT page):** Injects a Shadow DOM UI (toggle button + sidebar with tabs). Handles user interaction (clicks, form inputs) and updates UI. No heavy logic here. Uses chrome.runtime.sendMessage to talk to background. Must robustly attach to ChatGPT’s DOM (use data-type="unified-composer" form as anchor; MutationObserver to reattach if needed; fallback to fixed position if fails). Keep it lightweight and resilient to DOM changes.
- **Background Service Worker:** Core logic and state. Maintains:
- _Settings/Servers List:_ Stored in chrome.storage.sync. Contains servers (id, name, description, url, enabled) and defaultServerId. On install, seed with basic servers (e.g., Local Dev, Firecrawl placeholder).
- _MCP Connections:_ Manages active connections (e.g., WebSocket to local MCP servers). Use a map of serverId -> { ws, tools\[\], etc. }. On “CONNECT_MCP”, initiate connection (with JSON-RPC handshake: call initialize, then tools/list to get available tools)[\[9\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L226-L234)[\[96\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L230-L238).
- _Message Router:_ Listens for messages from content script. Implements message types: LIST_SERVERS, CONNECT_MCP, CALL_MCP_TOOL, TOGGLE_SERVER, SET_DEFAULT, GET/SET_SETTINGS, etc.[\[5\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L261-L270)[\[97\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L279-L288). Each returns a structured response (with ok and data or error). Ensure every path sendResponse exactly once and returns true for async.
- _Status & Logs:_ Keep last-known status per server (success/fail of last action) in chrome.storage.local and in-memory[\[45\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L346-L355). Append log entries for notable events (connections, errors, tool calls)[\[98\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L379-L385). Limit log size to 500 entries.
- **UI Tabs:**
- _Servers Tab:_ List all servers (name, description, status dot, maybe tags). Each entry: Connect/Echo button, Enable toggle, “Set default” button. Default server marked clearly[\[42\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=if%20%28state.defaultServerId%20%3D%3D%3D%20srv.id%29%20,header.appendChild%28badge%29%3B). Connect button: if server url starts with ws, attempt WebSocket connect; if it's a special case (like local echo HTTP), handle accordingly[\[34\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=btnConnect,res.tools%7C%7C%5B%5D%29.length%7D%20tools)[\[58\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L311-L320).
- _Tools Tab:_ When a server is connected (or default server selected), display its tools. For each tool: show name, an input field for JSON args (or a friendlier input if tool is known, e.g., URL for a “scrape” tool), and Run button[\[99\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=list.className%20%3D%20%27mcp,createElement%28%27button)[\[68\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=const%20run%20%3D%20document,showToast%28shadow%2C%20%27Tool%20OK). Running calls CALL_MCP_TOOL and then results are displayed (not just “Tool OK” toast – actually show output content).
- _Dev Tab:_ Show extension info (worker install time, current time)【5†】, and a scrollable log of recent events with a “Refresh” and “Clear” option【6†】. This is for debugging.
- _Settings Tab:_ Allow adding/editing/removing server entries. (Iteration B initial focus: maybe read-only list of seeded servers, but structure code to allow future addition UI.)
- **MCP Integration:** Primary external tool to integrate now is**Firecrawl (web scraper)**. Provide a way for user to input a URL and get page text via Firecrawl’s MCP server[\[37\]](https://docs.firecrawl.dev/mcp-server#:~:text=Features). Also plan for Memory and SequentialThinking servers (but can be stubbed or added later). Ensure the system can handle connecting to these servers if they’re running (likely via ws://localhost or wss URLs).
- **Message Schema:** Continue using { kind, requestId, payload } for requests[\[10\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L46-L54) and matching { requestId, ok, ... } for responses. Enumerate all kind strings in one place (so we don’t have typos). Possibly make TypeScript types for these messages.
- **Resilience & Performance:** Use MutationObserver on ChatGPT DOM (e.g., observe the form container) to remount UI if needed (ChatGPT SPA navigations, new chat, etc.). Debounce or throttle as appropriate. Ensure no memory leaks: clean up observers and event listeners on unmount if applicable. The service worker should handle being suspended – i.e., reinitialize connection info if it wakes up and state was lost (store minimal needed info in storage to restore if needed, e.g., which servers were connected last – though MV3 might terminate WS connections on suspend, so might need to reconnect on user action).
- **No Regression of Past Issues:**
- Maintain isolation: all UI in Shadow DOM (no CSS/JS leaking to page)[\[3\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L8-L10).
- No excessive permissions: do not add permissions beyond storage and necessary host perms.
- Clear separation: content script never directly calls network, background does; background never touches DOM.
- Thoroughly handle errors (e.g., if a tool call fails, show a toast or message in UI, but keep extension running).
- Keep UI responsive: avoid blocking UI thread (content script) with heavy loops.
- **Dev Practices for AI (you, the assistant):**
- Follow the design and constraints above strictly. If something is ambiguous, explain your reasoning or ask rather than assuming a risky design.
- Write clean, commented code in TS or JS as decided. Use descriptive names and JSDoc/types.
- No apologizing for actions – maintain a professional, solution-focused tone. If a past approach was wrong, simply state the new approach.
- Work incrementally: e.g., “First, let’s define the storage schema and types,” then code it; next, “Implement background message handling,” etc. Test each part if possible (you can describe how to test and what to expect).
- Ensure all features from section 3 (esp. Firecrawl integration) are implemented or at least scaffolded.
- Use logging liberally (debug logs for key actions) so we can trace execution in Dev tab.
- Remember to update documentation (README/CHANGELOG) as features are added.

**Immediate Next Steps:** Start by setting up the project structure (if using a bundler or just organizing files). Then implement the background script (with storage, message handlers, connection manager) followed by the content script (UI injection and basic interactions). After core functionality, integrate Firecrawl scrape as a use-case.

This prompt provides the AI with a clear picture of what we have and what we want. It emphasizes rules and avoids the pitfalls experienced earlier by explicitly instructing on tone and thoroughness. By feeding this to Cursor’s model, Jason can kick off coding the redesign with confidence that the AI has the full context and expectations.

[\[1\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md#L16-L24) [\[23\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md#L23-L31) [\[29\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md#L25-L32) [\[30\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md#L38-L44) [\[51\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md#L18-L26) [\[52\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md#L10-L18) DESIGN.md

[https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DESIGN.md)

[\[2\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L40-L43) [\[3\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L8-L10) [\[4\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L40-L48) [\[10\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L46-L54) [\[21\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L60-L64) [\[95\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md#L42-L44) README.md

[https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/README.md)

[\[5\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L261-L270) [\[6\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L34-L42) [\[7\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L101-L109) [\[8\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L198-L207) [\[9\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L226-L234) [\[11\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L42-L50) [\[12\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L70-L78) [\[13\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L100-L108) [\[14\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L86-L95) [\[15\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L353-L360) [\[16\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L376-L385) [\[17\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L380-L388) [\[45\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L346-L355) [\[47\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L186-L194) [\[49\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L92-L99) [\[50\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L412-L420) [\[53\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L2-L11) [\[54\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L407-L415) [\[55\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L18-L21) [\[56\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L156-L164) [\[57\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L166-L175) [\[58\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L311-L320) [\[59\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L324-L328) [\[60\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L361-L369) [\[61\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L112-L120) [\[62\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L121-L129) [\[70\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L388-L396) [\[86\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L26-L34) [\[87\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L194-L203) [\[96\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L230-L238) [\[97\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L279-L288) [\[98\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js#L379-L385) background.js

[https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/background.js)

[\[18\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=Operating%20rules%20for%20this%20project) [\[24\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=match%20at%20L875%20,reapply%20anchor%3B%20window%20resize%20handler) [\[25\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=const%20mo%20%3D%20new%20MutationObserver,window.addEventListener%28%27resize%27%2C%20reapply%29%3B) [\[26\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=const%20mo%20%3D%20new%20MutationObserver,reapply%29%3B) [\[28\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=match%20at%20L1068%20,handler%3B%20selectors%20avoid%20brittle%20classnames) [\[31\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=match%20at%20L872%20,documentElement%20to%20reapply%20anchor%3B%20window) [\[32\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=Of%20course%2C%20apologies%20for%20the,with%20logins%20and%20extension%20loading) [\[33\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=,documentElement%20to%20reapply%20anchor%3B%20window) [\[34\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=btnConnect,res.tools%7C%7C%5B%5D%29.length%7D%20tools) [\[35\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=try%20,OK%27%20%3A%20%27%21%27%2C%20color%3A%20isOk) [\[39\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=args%3A%20parsed%20,catch%20%28e%29) [\[40\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=%7D%29%3B%20const%20toggle%20%3D%20document.createElement%28,checked) [\[41\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=toggle.appendChild%28document.createTextNode%28) [\[42\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=if%20%28state.defaultServerId%20%3D%3D%3D%20srv.id%29%20,header.appendChild%28badge%29%3B) [\[43\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=header.className%20%3D%20%22mcp,name%22%3B%20name.textContent%20%3D%20srv.name) [\[44\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=dot.className%20%3D%20%22mcp,bad) [\[48\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=srv.url%20,res.tools%7C%7C%5B%5D%29.length%7D%20tools) [\[63\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=function%20render%28servers%2C%20state%2C%20statuses%29%20,item%22%3B%20li.dataset.id%20%3D%20srv.id) [\[64\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=function%20findComposerContainer%28%29%20,form) [\[65\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=match%20at%20L3187%20const%20shadow,refresh%28%29%3B) [\[66\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=const%20shadow%20%3D%20createShadowHost,refresh%28%29%3B) [\[67\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=function%20renderToolsUI%28container%2C%20id%2C%20tools%29%20,list%27%3B%20tools.forEach%28%28tool%29%20%3D%3E) [\[68\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=const%20run%20%3D%20document,showToast%28shadow%2C%20%27Tool%20OK) [\[69\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=%2F%2F%20render%20tools%20UI%20just,else) [\[71\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=const%20parsed%20%3D%20args,showToast%28shadow%2C%20%27Tool%20failed) [\[73\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=actions.className%20%3D%20%22mcp,url) [\[76\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=) [\[83\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=match%20at%20L887%20,MCP%2C%20Sequential%20Thinking%2C%20Streamable%2C%20Memory) [\[92\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=Planning%20tasks%20for%20Iteration%20A,brief%20%2B%20constraints) [\[93\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=3) [\[94\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=1) [\[99\]](file://file-1pwLr3T67sC8Z1vDi9xPsd#:~:text=list.className%20%3D%20%27mcp,createElement%28%27button) cursor_developing_a_chrome_mv3_extensio.md

file://file-1pwLr3T67sC8Z1vDi9xPsd

[\[19\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DECISIONS.md#L2-L6) [\[72\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DECISIONS.md#L8-L13) [\[75\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DECISIONS.md#L29-L33) DECISIONS.md

[https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DECISIONS.md](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/DECISIONS.md)

[\[20\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/manifest.json#L9-L17) [\[74\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/manifest.json#L12-L17) manifest.json

[https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/manifest.json](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/manifest.json)

[\[22\]](file://file-3ZPr3e7BhXfnwbhJc458qs#:~:text=aria,areas%3A%27header_header_header%27_%27primary_prim) [\[27\]](file://file-3ZPr3e7BhXfnwbhJc458qs#:~:text=h,thread) [\[46\]](file://file-3ZPr3e7BhXfnwbhJc458qs#:~:text=expanded%2Fcomposer%3Apx,hidden%22%3E%3C%2Fp%3E%3C%2Fdiv%3E%3C%2Fdiv%3E%3C%2Fdiv%3E%3Cdiv) ChatGPT (9_3_2025 6：08：38 PM).html

file://file-3ZPr3e7BhXfnwbhJc458qs

[\[36\]](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/scripts/mcp-localdev.js#L18-L26) mcp-localdev.js

[https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/scripts/mcp-localdev.js](https://github.com/jasonshaw0/MCPWebBridge/blob/1d0b31068cf82b301edc25bbd83cfc1a55e81fed/scripts/mcp-localdev.js)

[\[37\]](https://docs.firecrawl.dev/mcp-server#:~:text=Features) [\[78\]](https://docs.firecrawl.dev/mcp-server#:~:text=You%20can%20either%20use%20our,keys) [\[79\]](https://docs.firecrawl.dev/mcp-server#:~:text=Copy) [\[88\]](https://docs.firecrawl.dev/mcp-server#:~:text=Ask%20AI) Firecrawl MCP Server

[https://docs.firecrawl.dev/mcp-server](https://docs.firecrawl.dev/mcp-server)

[\[38\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20Memory%20,Time%20and%20timezone%20conversion%20capabilities) [\[77\]](https://github.com/modelcontextprotocol/servers#:~:text=The%20servers%20in%20this%20repository,implemented%20with%20an%20MCP%20SDK) [\[80\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20Filesystem%20%20,solving%20through%20thought%20sequences) [\[81\]](https://github.com/modelcontextprotocol/servers#:~:text=For%20example%2C%20this%20will%20start,the%20Memory%20server) [\[82\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20Fetch%20,based%20persistent%20memory%20system) [\[84\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20Google%20Maps%20%20,interaction%20and%20business%20intelligence%20capabilities) [\[85\]](https://github.com/modelcontextprotocol/servers#:~:text=%2A%20BrowserLoop%20,capture%20with%20configurable%20formats%2C%20viewport) GitHub - modelcontextprotocol/servers: Model Context Protocol Servers

[https://github.com/modelcontextprotocol/servers](https://github.com/modelcontextprotocol/servers)

[\[89\]](https://github.com/wxt-dev/wxt#:~:text=wxt,imports%20%C2%B7) [\[91\]](https://github.com/wxt-dev/wxt#:~:text=Features%20%C2%B7%20Supports%20all%20browsers,imports%20%C2%B7) wxt-dev/wxt: Next-gen Web Extension Framework - GitHub

[https://github.com/wxt-dev/wxt](https://github.com/wxt-dev/wxt)

[\[90\]](https://www.reddit.com/r/chrome_extensions/comments/1fs9om2/i_wrote_wxt_a_relatively_new_framework_for/#:~:text=I%20wrote%20WXT%2C%20a%20relatively,that%20automatically%20opens%20the%20browser) I wrote WXT, a relatively new framework for building web extensions ...

[https://www.reddit.com/r/chrome_extensions/comments/1fs9om2/i_wrote_wxt_a_relatively_new_framework_for/](https://www.reddit.com/r/chrome_extensions/comments/1fs9om2/i_wrote_wxt_a_relatively_new_framework_for/)
